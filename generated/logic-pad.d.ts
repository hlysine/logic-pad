declare global {
  // Generated by dts-bundle v0.7.3
  // Dependencies for this module:
  //   ../../../../zod
  //   ../../../../z3-solver
  //   ../../../../grilops
  //   ../../../../react-icons/md

  import { z } from 'zod';
  import { Solver, Optimize } from 'z3-solver';
  import { RegionConstrainer, SymbolGrid } from 'grilops';
  import { Optimize, Solver } from 'z3-solver';
  import type Md from 'react-icons/md';

  export enum ConfigType {
    Boolean = 'boolean',
    Number = 'number',
    String = 'string',
    Color = 'color',
    Direction = 'direction',
    DirectionToggle = 'directionToggle',
    Orientation = 'orientation',
    OrientationToggle = 'orientationToggle',
    Tile = 'tile',
    Solution = 'solution',
    Grid = 'grid',
    Icon = 'icon',
  }
  export interface Config<T> {
    readonly type: ConfigType;
    readonly field: string;
    readonly description: string;
    readonly default: T;
    readonly configurable: boolean;
  }
  export interface BooleanConfig extends Config<boolean> {
    readonly type: ConfigType.Boolean;
  }
  export interface NumberConfig extends Config<number> {
    readonly type: ConfigType.Number;
    readonly min?: number;
    readonly max?: number;
  }
  export interface StringConfig extends Config<string> {
    readonly type: ConfigType.String;
    readonly maxLength?: number;
    readonly placeholder?: string;
  }
  export interface ColorConfig extends Config<Color> {
    readonly type: ConfigType.Color;
    readonly allowGray: boolean;
  }
  export interface DirectionConfig extends Config<Direction> {
    readonly type: ConfigType.Direction;
  }
  export interface DirectionToggleConfig extends Config<DirectionToggle> {
    readonly type: ConfigType.DirectionToggle;
  }
  export interface OrientationConfig extends Config<Orientation> {
    readonly type: ConfigType.Orientation;
  }
  export interface OrientationToggleConfig extends Config<OrientationToggle> {
    readonly type: ConfigType.OrientationToggle;
  }
  export interface TileConfig extends Config<GridData> {
    readonly type: ConfigType.Tile;
    readonly resizable: boolean;
  }
  export interface SolutionConfig extends Config<GridData> {
    readonly type: ConfigType.Solution;
  }
  export interface GridConfig extends Config<GridData> {
    readonly type: ConfigType.Grid;
  }
  export interface IconConfig extends Config<string> {
    readonly type: ConfigType.Icon;
  }
  export type AnyConfig =
    | BooleanConfig
    | NumberConfig
    | StringConfig
    | ColorConfig
    | DirectionConfig
    | DirectionToggleConfig
    | OrientationConfig
    | OrientationToggleConfig
    | TileConfig
    | SolutionConfig
    | GridConfig
    | IconConfig;
  /**
   * Compare two config values for equality, using an appropriate method for the config type.
   *
   * @param type The type of the config.
   * @param a The first value to compare.
   * @param b The second value to compare.
   * @returns Whether the two values are equal.
   */
  export function configEquals<C extends AnyConfig>(
    type: C['type'],
    a: C['default'],
    b: C['default']
  ): boolean;

  export function isEventHandler<T>(val: unknown, event: string): val is T;

  export interface FinalValidationHandler {
    /**
     * Edits the final grid state after all rules and symbols have been validated.
     *
     * @param grid The grid that is being validated.
     * @param solution The solution grid, or null if the solution is not available.
     * @param state The current state of the grid.
     */
    onFinalValidation(
      grid: GridData,
      solution: GridData | null,
      state: GridState
    ): GridState;
  }
  export function handlesFinalValidation<T extends Instruction>(
    val: T
  ): val is T & FinalValidationHandler;

  export interface SymbolValidationHandler {
    /**
     * Overrides the validation of symbols.
     *
     * You can return a different validation result, or call the original validation logic with a modified grid.
     *
     * @param grid - The grid to validate.
     * @param _symbol - The symbol to validate.
     * @param validator - The original validation logic for the symbol.
     * @returns The state of the symbol after validation.
     */
    onSymbolValidation(
      grid: GridData,
      symbol: Symbol,
      validator: (grid: GridData) => State
    ): State | undefined;
  }
  export function handlesSymbolValidation<T extends Rule>(
    val: T
  ): val is T & SymbolValidationHandler;

  export class GridData {
    readonly width: number;
    readonly height: number;
    readonly tiles: readonly (readonly TileData[])[];
    readonly connections: GridConnections;
    readonly symbols: ReadonlyMap<string, readonly Symbol[]>;
    readonly rules: readonly Rule[];
    /**
     * Create a new grid with tiles, connections, symbols and rules.
     * @param width The width of the grid.
     * @param height The height of the grid.
     * @param tiles The tiles of the grid.
     * @param connections The connections of the grid, which determines which tiles are merged.
     * @param symbols The symbols in the grid.
     * @param rules The rules of the grid.
     */
    constructor(
      width: number,
      height: number,
      tiles?: readonly (readonly TileData[])[],
      connections?: GridConnections,
      symbols?: ReadonlyMap<string, readonly Symbol[]>,
      rules?: readonly Rule[]
    );
    /**
     * Copy the current grid while modifying the provided properties.
     * @param param0 The properties to modify.
     * @returns The new grid with the modified properties.
     */
    copyWith({
      width,
      height,
      tiles,
      connections,
      symbols,
      rules,
    }: {
      width?: number;
      height?: number;
      tiles?: readonly (readonly TileData[])[];
      connections?: GridConnections;
      symbols?: ReadonlyMap<string, readonly Symbol[]>;
      rules?: readonly Rule[];
    }): GridData;
    isPositionValid(x: number, y: number): boolean;
    /**
     * Safely get the tile at the given position.
     * @param x The x-coordinate of the tile.
     * @param y The y-coordinate of the tile.
     * @returns The tile at the given position, or a non-existent tile if the position is invalid.
     */
    getTile(x: number, y: number): TileData;
    /**
     * Safely set the tile at the given position.
     * If the position is invalid, the grid is returned unchanged.
     * If the tile is merged with other tiles, the colors of all connected tiles are changed.
     *
     * @param x The x-coordinate of the tile.
     * @param y The y-coordinate of the tile.
     * @param tile The new tile to set.
     * @returns The new grid with the tile set at the given position.
     */
    setTile(
      x: number,
      y: number,
      tile: TileData | ((tile: TileData) => TileData)
    ): GridData;
    /**
     * Replace or modify all tiles in the grid.
     *
     * @param tiles The new tile array or a function to mutate the existing tile array.
     * @returns The new grid with the new tiles.
     */
    withTiles(
      tiles:
        | readonly (readonly TileData[])[]
        | ((value: TileData[][]) => readonly (readonly TileData[])[])
    ): GridData;
    /**
     * Add or modify the connections in the grid.
     * @param connections The new connections to add or modify.
     * @returns The new grid with the new connections.
     */
    withConnections(
      connections:
        | GridConnections
        | ((value: GridConnections) => GridConnections)
    ): GridData;
    /**
     * Add or modify the symbols in the grid.
     * @param symbols The new symbols to add or modify.
     * @returns The new grid with the new symbols.
     */
    withSymbols(
      symbols:
        | readonly Symbol[]
        | ReadonlyMap<string, readonly Symbol[]>
        | ((
            value: Map<string, readonly Symbol[]>
          ) => ReadonlyMap<string, readonly Symbol[]>)
    ): GridData;
    /**
     * Add a new symbol to the grid.
     * @param symbol The symbol to add.
     * @returns The new grid with the new symbol.
     */
    addSymbol(symbol: Symbol): GridData;
    /**
     * Remove an instance of the symbol from the grid.
     * @param symbol The symbol to remove.
     * @returns The new grid with the symbol removed.
     */
    removeSymbol(symbol: Symbol): GridData;
    /**
     * Remove all symbols that satisfy the predicate.
     * @param predicate The predicate to test each symbol with.
     * @returns The new grid with the symbols removed.
     */
    removeSymbolIf(predicate: (symbol: Symbol) => boolean): GridData;
    /**
     * Find the first symbol that satisfies the predicate.
     * @param predicate The predicate to test each symbol with.
     * @returns The first symbol that satisfies the predicate, or undefined if no symbol is found.
     */
    findSymbol(predicate: (symbol: Symbol) => boolean): Symbol | undefined;
    /**
     * Replace an existing symbol with a new symbol.
     * @param oldSymbol The symbol to replace.
     * @param newSymbol The new symbol to replace with.
     * @returns The new grid with the symbol replaced.
     */
    replaceSymbol(oldSymbol: Symbol, newSymbol: Symbol): GridData;
    /**
     * Add or modify the rules in the grid.
     * @param rules The new rules to add or modify.
     * @returns The new grid with the new rules.
     */
    withRules(
      rules: readonly Rule[] | ((value: readonly Rule[]) => readonly Rule[])
    ): GridData;
    /**
     * Add a new rule to the grid.
     * @param rule The rule to add.
     * @returns The new grid with the new rule.
     */
    addRule(rule: Rule): GridData;
    /**
     * Remove an instance of the rule from the grid.
     * @param rule The rule to remove.
     * @returns The new grid with the rule removed.
     */
    removeRule(rule: Rule): GridData;
    /**
     * Remove all rules that satisfy the predicate.
     * @param predicate The predicate to test each rule with.
     * @returns The new grid with the rules removed.
     */
    removeRuleIf(predicate: (rule: Rule) => boolean): GridData;
    /**
     * Find the first rule that satisfies the predicate.
     * @param predicate The predicate to test each rule with.
     * @returns The first rule that satisfies the predicate, or undefined if no rule is found.
     */
    findRule(predicate: (rule: Rule) => boolean): Rule | undefined;
    /**
     * Replace an existing rule with a new rule.
     * @param oldRule The rule to replace.
     * @param newRule The new rule to replace with.
     * @returns The new grid with the rule replaced.
     */
    replaceRule(oldRule: Rule, newRule: Rule): GridData;
    /**
     * Resize the grid to the new width and height. Common tiles are kept, and new tiles are empty.
     * @param width The new width of the grid.
     * @param height The new height of the grid.
     * @returns The new grid with the new dimensions.
     */
    resize(width: number, height: number): GridData;
    /**
     * Create a new mutable TileData array from a string array.
     *
     * - Use `b` for dark cells, `w` for light cells, and `n` for gray cells.
     * - Capitalize the letter to make the tile fixed.
     * - Use `.` to represent empty space.
     *
     * @param array - The string array to create the tiles from.
     * @returns The created tile array.
     */
    static createTiles(array: string[]): TileData[][];
    /**
     * Create a new GridData object from a string array.
     *
     * - Use `b` for dark cells, `w` for light cells, and `n` for gray cells.
     * - Capitalize the letter to make the tile fixed.
     * - Use `.` to represent empty space.
     *
     * @param array - The string array to create the grid from.
     * @returns The created grid.
     */
    static create(array: string[]): GridData;
    /**
     * Find a tile in the grid that satisfies the predicate.
     *
     * @param predicate The predicate to test each tile with.
     * @returns The position of the first tile that satisfies the predicate, or undefined if no tile is found.
     */
    find(
      predicate: (tile: TileData, x: number, y: number) => boolean
    ): Position | undefined;
    /**
     * Iterate over all tiles in the same region as the given position that satisfy the predicate.
     * The iteration stops when the callback returns a value that is not undefined.
     * Non-existent tiles are not included in the iteration.
     *
     * @param position The position to start the iteration from. This position is included in the iteration.
     * @param predicate The predicate to test each tile with. The callback is only called for tiles that satisfy this predicate.
     * @param callback The callback to call for each tile that satisfies the predicate. The iteration stops when this callback returns a value that is not undefined.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    iterateArea<T>(
      position: Position,
      predicate: (tile: TileData) => boolean,
      callback: (tile: TileData, x: number, y: number) => undefined | T
    ): T | undefined;
    /**
     * Iterate over all tiles in a straight line from the given position in the given direction that satisfy the predicate.
     * The iteration stops when the callback returns a value that is not undefined.
     * Non-existent tiles break the iteration.
     *
     * @param position The position to start the iteration from. This position is included in the iteration.
     * @param direction The direction to iterate in.
     * @param predicate The predicate to test each tile with. The callback is only called for tiles that satisfy this predicate.
     * @param callback The callback to call for each tile that satisfies the predicate. The iteration stops when this callback returns a value that is not undefined.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    iterateDirection<T>(
      position: Position,
      direction: Direction | Orientation,
      predicate: (tile: TileData) => boolean,
      callback: (tile: TileData, x: number, y: number) => T | undefined
    ): T | undefined;
    /**
     * Iterate over all tiles in a straight line from the given position in the given direction that satisfy the predicate.
     * The iteration stops when the callback returns a value that is not undefined.
     * Non-existent tiles are included in the iteration.
     *
     * @param position The position to start the iteration from. This position is included in the iteration.
     * @param direction The direction to iterate in.
     * @param predicate The predicate to test each tile with. The callback is only called for tiles that satisfy this predicate.
     * @param callback The callback to call for each tile that satisfies the predicate. The iteration stops when this callback returns a value that is not undefined.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    iterateDirectionAll<T>(
      position: Position,
      direction: Direction | Orientation,
      predicate: (tile: TileData) => boolean,
      callback: (tile: TileData, x: number, y: number) => T | undefined
    ): T | undefined;
    /**
     * Check if every tile in the grid is filled with a color other than gray.
     *
     * @returns True if every tile is filled with a color other than gray, false otherwise.
     */
    isComplete(): boolean;
    /**
     * Iterate over all tiles in the grid.
     * The iteration stops when the callback returns a value that is not undefined.
     *
     * @param callback The callback to call for each tile.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    forEach<T>(
      callback: (tile: TileData, x: number, y: number) => T | undefined
    ): T | undefined;
    /**
     * Flood fill a continuous region starting from the given position with the given color.
     *
     * @param position The position to start the flood fill from.
     * @param from The color of the tiles to fill.
     * @param to The color to fill the tiles with.
     * @returns The new grid with the region filled with the new color.
     */
    floodFill(position: Position, from: Color, to: Color): GridData;
    /**
     * Flood fill all tiles with the given color to a new color, even if they are not connected.
     *
     * @param from The color of the tiles to fill.
     * @param to The color to fill the tiles with.
     * @returns The new grid with all tiles filled with the new color.
     */
    floodFillAll(from: Color, to: Color): GridData;
    /**
     * Check if the grid has any instructions that require a custom solution.
     * @returns True if the grid has any instructions that require a custom solution, false otherwise.
     */
    requireSolution(): boolean;
    /**
     * Reset all non-fixed tiles to gray.
     *
     * @returns The new grid with all non-fixed tiles reset to gray.
     */
    resetTiles(): GridData;
    /**
     * Copy the tiles in the given region to a new grid.
     * All connections and symbols within the selected region are copied.
     * All rules are included as well.
     *
     * @param origin The top-left corner of the region to copy.
     * @param width The width of the region to copy.
     * @param height The height of the region to copy.
     * @returns The new grid with the copied tiles.
     */
    copyTiles(origin: Position, width: number, height: number): GridData;
    /**
     * Paste the tiles from the given grid to the current grid at the given position.
     * All connections, symbols, and rules are merged.
     *
     * @param origin The top-left corner of the region to paste the tiles to.
     * @param grid The grid to paste the tiles from.
     * @returns The new grid with the pasted tiles.
     */
    pasteTiles(origin: Position, grid: GridData): GridData;
    /**
     * Paste the tiles from the given array to the current grid at the given position.
     *
     * @param origin The top-left corner of the region to paste the tiles to.
     * @param tile The array of tiles to paste.
     * @returns The new grid with the pasted tiles.
     */
    pasteTiles(
      origin: Position,
      tile: readonly (readonly TileData[])[]
    ): GridData;
    /**
     * Check if this grid is equal to another grid in terms of size and tile colors.
     * Rules, symbols, and connections are not compared.
     *
     * @param grid The grid to compare with.
     * @returns True if the grids are equal in size and tile colors, false otherwise.
     */
    colorEquals(grid: GridData): boolean;
    /**
     * Check if this grid is equal to another grid in terms of size, tile colors, connections, symbols, and rules.
     *
     * @param other The grid to compare with.
     * @returns True if the grids are equal, false otherwise.
     */
    equals(other: GridData): boolean;
    /**
     * Get the count of tiles that satisfy the given conditions.
     * @param exists Whether the tile exists or not.
     * @param fixed Whether the tile is fixed or not. If undefined, the fixed state is ignored.
     * @param color The color of the tile. If undefined, all colors are included.
     * @returns The count of tiles that satisfy the given conditions.
     */
    getTileCount(
      exists: boolean,
      fixed?: boolean | undefined,
      color?: Color | undefined
    ): number;
    /**
     * Get the count of tiles that satisfy the given conditions for each color.
     * @param color The color of the tiles.
     * @returns The count of tiles that satisfy the given conditions for each color.
     */
    getColorCount(color: Color): {
      min: number;
      max: number;
    };
    /**
     * Deduplicate the rules in the given list.
     *
     * @param rules The list of rules to deduplicate.
     * @returns The deduplicated list of rules.
     */
    static deduplicateRules(rules: readonly Rule[]): readonly Rule[];
    /**
     * Deduplicate the symbols in the given map.
     *
     * @param symbols The map of symbols to deduplicate.
     * @returns The deduplicated map of symbols.
     */
    static deduplicateSymbols(
      symbols: ReadonlyMap<string, readonly Symbol[]>
    ): ReadonlyMap<string, readonly Symbol[]>;
  }

  export class GridConnections {
    readonly edges: readonly Edge[];
    constructor(edges?: readonly Edge[]);
    addEdge(edge: Edge): GridConnections;
    removeEdge(edge: Edge): GridConnections;
    isConnected(edge: Edge): boolean;
    getConnectionsAt({ x, y }: Position): readonly Edge[];
    getForTile({ x, y }: Position): TileConnections;
    getConnectedTiles({ x, y }: Position): readonly Position[];
    /**
     * Create new GridConnections from a string array.
     *
     * - Use `.` for cells that don't connect to anything.
     * - Use any other character for cells that connect to the same character.
     *
     * @param array - The string array to create the connections from.
     * @returns The created connections. You can apply this to a GridData object using GridData.withConnections.
     */
    static create(array: string[]): GridConnections;
    /**
     * Check if two GridConnections objects are equal.
     * @param other The other GridConnections object to compare to.
     * @returns Whether the two objects are equal.
     */
    equals(other: GridConnections): boolean;
    /**
     * Deduplicate an array of edges.
     * @param edges The array of edges to deduplicate.
     * @returns The deduplicated array of edges.
     */
    static deduplicateEdges(edges: readonly Edge[]): readonly Edge[];
  }

  /**
   * Offset the given position by a given step in the given direction.
   * @param position The position to offset.
   * @param direction The direction to offset in.
   * @param step The distance to offset by.
   * @returns The offset position.
   */
  export function move(
    position: Position,
    direction: Direction | Orientation,
    step?: number
  ): {
    x: number;
    y: number;
  };
  /**
   * Convert the given direction to a rotation in degrees.
   * @param direction The direction to convert.
   * @returns The rotation in degrees.
   */
  export function directionToRotation(direction: Direction): 0 | 270 | 90 | 180;
  /**
   * Convert the given orientation to a rotation in degrees.
   * @param orientation The orientation to convert.
   * @returns The rotation in degrees.
   */
  export function orientationToRotation(
    orientation: Orientation
  ): 0 | 270 | 90 | 180 | 225 | 125 | 315 | 45;
  /**
   * Create a new 2D array with the given dimensions and values.
   * @param width The width of the array.
   * @param height The height of the array.
   * @param value A function that returns the value for each x,y coordinate.
   * @returns The 2D array.
   */
  export function array<T>(
    width: number,
    height: number,
    value: (x: number, y: number) => T
  ): T[][];
  /**
   * Check if all the given values are equal.
   * @param values The values to compare.
   * @returns Whether all the values are equal.
   */
  export function allEqual<T>(...values: T[]): boolean;
  /**
   * Return the first element of the array which has the minimum mapped value.
   *
   * @param values The array of values.
   * @param mapper The function to map each value to a number.
   * @returns The first element with the minimum mapped value.
   */
  export function minBy<T>(
    values: readonly T[],
    mapper: (element: T) => number
  ): T | undefined;
  /**
   * Return the first element of the array which has the maximum mapped value.
   *
   * @param values The array of values.
   * @param mapper The function to map each value to a number.
   * @returns The first element with the maximum mapped value.
   */
  export function maxBy<T>(
    values: readonly T[],
    mapper: (element: T) => number
  ): T | undefined;
  /**
   * Escape the given text by replacing the specified characters with HTML escape sequences.
   * @param text The text to escape.
   * @param escapeCharacters The characters to escape.
   * @returns The escaped text.
   */
  export function escape(text: string, escapeCharacters?: string): string;
  /**
   * Unescape the given text by replacing HTML escape sequences with the corresponding characters.
   * @param text The text to unescape.
   * @param escapeCharacters The characters to unescape. This should match the characters escaped by the `escape` function.
   * @returns The unescaped text.
   */
  export function unescape(text: string, escapeCharacters?: string): string;

  export abstract class Instruction {
    abstract get id(): string;
    abstract get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    abstract createExampleGrid(): GridData;
    abstract copyWith(props: Record<string, unknown>): this;
    /**
     * Indicates that validation by logic is not available and the solution must be used for validation
     */
    get validateWithSolution(): boolean;
    /**
     * Check if this instruction is equal to another instruction by comparing their IDs and configs.
     *
     * @param other The other instruction to compare to.
     * @returns Whether the two instructions are equal.
     */
    equals(other: Instruction): boolean;
  }

  export interface Position {
    readonly x: number;
    readonly y: number;
  }
  export interface Edge {
    readonly x1: number;
    readonly y1: number;
    readonly x2: number;
    readonly y2: number;
  }
  export enum State {
    Error = 'error',
    Satisfied = 'satisfied',
    Incomplete = 'incomplete',
  }
  export type RuleState =
    | {
        readonly state: State.Error;
        readonly positions: readonly Position[];
      }
    | {
        readonly state: State.Satisfied;
      }
    | {
        readonly state: State.Incomplete;
      };
  export interface GridState {
    final: State;
    rules: readonly RuleState[];
    symbols: ReadonlyMap<string, State[]>;
  }
  export enum Color {
    Dark = 'dark',
    Light = 'light',
    Gray = 'gray',
  }
  export enum Direction {
    Up = 'up',
    Down = 'down',
    Left = 'left',
    Right = 'right',
  }
  export const DIRECTIONS: readonly Direction[];
  export type DirectionMap<T> = {
    [key in Direction]: T;
  };
  export type DirectionToggle = Readonly<DirectionMap<boolean>>;
  export function directionToggle(...directions: readonly Direction[]): {
    up: boolean;
    down: boolean;
    left: boolean;
    right: boolean;
  };
  export enum Orientation {
    Up = 'up',
    UpRight = 'up-right',
    Right = 'right',
    DownRight = 'down-right',
    Down = 'down',
    DownLeft = 'down-left',
    Left = 'left',
    UpLeft = 'up-left',
  }
  export const ORIENTATIONS: readonly Orientation[];
  export type OrientationMap<T> = {
    [key in Orientation]: T;
  };
  export type OrientationToggle = Readonly<OrientationMap<boolean>>;
  export function orientationToggle(...orientations: readonly Orientation[]): {
    up: boolean;
    'up-right': boolean;
    right: boolean;
    'down-right': boolean;
    down: boolean;
    'down-left': boolean;
    left: boolean;
    'up-left': boolean;
  };
  export enum Mode {
    Create = 'create',
    Solve = 'solve',
  }

  export type PuzzleMetadata = {
    /**
     * The title of the puzzle. (required)
     */
    title: string;
    /**
     * The author of the puzzle. (required)
     */
    author: string;
    /**
     * A description of the puzzle. (can be empty)
     */
    description: string;
    /**
     * A link to a place to discuss this puzzle. (can be empty)
     */
    link: string;
    /**
     * The difficulty of the puzzle, from 1 to 10. (required)
     *
     * 6-10 represent star difficulties.
     */
    difficulty: number;
  };
  export const MetadataSchema: z.ZodObject<
    {
      title: z.ZodString;
      author: z.ZodString;
      description: z.ZodString;
      link: z.ZodString;
      difficulty: z.ZodNumber;
    },
    'strict',
    z.ZodTypeAny,
    {
      link: string;
      description: string;
      title: string;
      author: string;
      difficulty: number;
    },
    {
      link: string;
      description: string;
      title: string;
      author: string;
      difficulty: number;
    }
  >;
  export const PuzzleSchema: z.ZodObject<
    {
      title: z.ZodString;
      author: z.ZodString;
      description: z.ZodString;
      link: z.ZodString;
      difficulty: z.ZodNumber;
      grid: z.ZodType<GridData, z.ZodTypeDef, GridData>;
      solution: z.ZodNullable<z.ZodType<GridData, z.ZodTypeDef, GridData>>;
    },
    'strict',
    z.ZodTypeAny,
    {
      link: string;
      solution: GridData | null;
      grid: GridData;
      description: string;
      title: string;
      author: string;
      difficulty: number;
    },
    {
      link: string;
      solution: GridData | null;
      grid: GridData;
      description: string;
      title: string;
      author: string;
      difficulty: number;
    }
  >;
  export type Puzzle = PuzzleMetadata & {
    /**
     * The grid of the puzzle. (required)
     *
     * You must fix all given cells in the grid. The rest of the cells will be cleared.
     */
    grid: GridData;
    /**
     * The solution to the puzzle. (optional)
     *
     * You should provide a solution if a rule requires it. Otherwise, the rule can never be satisfied.
     *
     * If there are no rules that require a solution, this field will be ignored.
     */
    solution: GridData | null;
  };

  export class BanPatternRule extends Rule {
    readonly pattern: GridData;
    /**
     * **Don't make this pattern**
     *
     * @param pattern - GridData representing the banned pattern. Only non-gray tiles are considered.
     */
    constructor(pattern: GridData);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ pattern }: { pattern?: GridData }): this;
    withPattern(pattern: GridData): this;
  }

  export class CellCountRule extends Rule {
    readonly color: Color;
    readonly count: number;
    /**
     * **There are &lt;count&gt; &lt;color&gt; cells in total**
     *
     * @param color - The color of the cells to count.
     * @param count - The total number of cells of the given color.
     */
    constructor(color: Color, count: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color, count }: { color?: Color; count?: number }): this;
    withColor(color: Color): this;
    withCount(count: number): this;
  }

  export class CompletePatternRule extends Rule {
    /**
     * **Complete the pattern**
     *
     * This rule validates answers based on the provided solution.
     */
    constructor();
    get id(): string;
    get explanation(): string;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    copyWith(_: object): this;
    get validateWithSolution(): boolean;
  }

  export class ConnectAllRule extends Rule {
    readonly color: Color;
    /**
     * **Connect all &lt;color&gt; cells**
     *
     * @param color - The color of the cells to connect.
     */
    constructor(color: Color);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color }: { color?: Color }): this;
    withColor(color: Color): this;
  }

  export class CustomRule extends Rule {
    readonly description: string;
    readonly grid: GridData;
    static readonly configs: readonly AnyConfig[];
    /**
     * A custom rule with a description and thumbnail grid.
     *
     * This rule validates answers based on the provided solution.
     *
     * @param description - The description of the rule.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     */
    constructor(description: string, grid: GridData);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    copyWith({
      description,
      grid,
    }: {
      description?: string;
      grid?: GridData;
    }): this;
    get validateWithSolution(): boolean;
  }

  const allRules: Map<string, Rule>;
  export { allRules };

  export class MysteryRule extends Rule implements FinalValidationHandler {
    readonly solution: GridData;
    readonly visible: boolean;
    /**
     * **Mystery: alternate solution**
     */
    constructor(solution: GridData, visible: boolean);
    get id(): string;
    get explanation(): string;
    get visibleWhenSolving(): boolean;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    onFinalValidation(
      grid: GridData,
      _solution: GridData | null,
      state: GridState
    ): GridState;
    copyWith({
      solution,
      visible,
    }: {
      solution?: GridData;
      visible?: boolean;
    }): this;
    withSolution(solution: GridData): this;
    withVisible(visible: boolean): this;
    static cleanSolution(solution: GridData, baseGrid?: GridData): GridData;
  }

  export class OffByXRule extends Rule implements SymbolValidationHandler {
    readonly number: number;
    /**
     * **All numbers are off by &lt;number&gt;**
     *
     * @param number - The number that all cells are off by.
     */
    constructor(number: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    onSymbolValidation(
      grid: GridData,
      symbol: Symbol,
      _validator: (grid: GridData) => State
    ): State | undefined;
    copyWith({ number }: { number?: number }): this;
    withNumber(number: number): this;
  }

  export class RegionAreaRule extends Rule {
    readonly color: Color;
    readonly size: number;
    /**
     * **All &lt;color&gt; regions have area &lt;size&gt;**
     *
     * @param color - The color of the regions.
     * @param size - The area of the regions.
     */
    constructor(color: Color, size: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color, size }: { color?: Color; size?: number }): this;
    withColor(color: Color): this;
    withSize(size: number): this;
  }

  export type ShapeRegions = {
    regions: {
      positions: Position[];
      shape: Shape;
      count: number;
    }[];
    complete: boolean;
  };
  export abstract class RegionShapeRule extends Rule {
    readonly color: Color;
    /**
     * @param color - The color of the regions to compare.
     */
    constructor(color: Color);
    protected getShapeRegions(grid: GridData): ShapeRegions;
    withColor(color: Color): this;
  }

  export interface SearchVariant {
    description: string;
    rule: Rule;
  }
  export abstract class Rule extends Instruction {
    abstract validateGrid(grid: GridData): RuleState;
    statusText(
      _grid: GridData,
      _solution: GridData | null,
      _state: GridState
    ): string | null;
    abstract get searchVariants(): SearchVariant[];
    searchVariant(): SearchVariant;
    get visibleWhenSolving(): boolean;
  }

  export class SameShapeRule extends RegionShapeRule {
    /**
     * **All &lt;color&gt; areas have the same shape and size**
     *
     * @param color - The color of the regions to compare.
     */
    constructor(color: Color);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color }: { color?: Color }): this;
  }

  export class SymbolsPerRegionRule extends Rule {
    readonly color: Color;
    readonly count: number;
    /**
     * **Exactly &lt;count&gt; symbols per &lt;color&gt; area**
     *
     * @param color - Color of the region affected by the rule
     * @param count - Number of symbols to have in each region
     */
    constructor(color: Color, count: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ count, color }: { count?: number; color?: Color }): this;
    withColor(color: Color): this;
    withCount(count: number): this;
  }

  export class UndercluedRule extends Rule {
    /**
     * **Underclued Grid: Mark only what is definitely true**
     *
     * This rule validates answers based on the provided solution.
     */
    constructor();
    get id(): string;
    get explanation(): string;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    copyWith(_: object): this;
    get validateWithSolution(): boolean;
    statusText(
      grid: GridData,
      solution: GridData | null,
      _state: GridState
    ): string | null;
  }

  export class UniqueShapeRule extends RegionShapeRule {
    /**
     * **No two &lt;color&gt; areas have the same shape and size**
     *
     * @param color - The color of the regions to compare.
     */
    constructor(color: Color);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color }: { color?: Color }): this;
  }

  /**
   * The master serializer for puzzles.
   *
   * It uses the default serializer when stringifying puzzles, and select the correct deserializer when parsing puzzles.
   */
  const Serializer: {
    stringifySymbol(symbol: Symbol): string;
    parseSymbol(input: string): Symbol;
    stringifyGrid(grid: GridData): string;
    parseGrid(input: string): GridData;
    /**
     * Convert a puzzle to a string.
     * @param puzzle The puzzle to convert.
     * @returns The string representation of the puzzle.
     */
    stringifyPuzzle(puzzle: Puzzle): string;
    /**
     * Parse a puzzle from a string.
     * @param input The string to parse.
     * @returns The parsed puzzle.
     */
    parsePuzzle(input: string): Puzzle;
  };
  export { Serializer };

  /**
   * The master compressor for compressing and decompressing strings.
   *
   * It compares the output of multiple compressors and selects the one with the smallest size (slow),
   * and selects the correct decompressor when decompressing.
   */
  class MasterCompressor extends CompressorBase {
    get id(): string;
    compress(input: string): Promise<string>;
    decompress(input: string): Promise<string>;
  }
  const Compressor: MasterCompressor;
  export { Compressor };

  export abstract class CompressorBase {
    /**
     * The unique identifier for this compressor.
     */
    abstract get id(): string;
    /**
     * Compress the given input string into URL-safe compressed string.
     * @param input The input string to compress.
     */
    abstract compress(input: string): Promise<string>;
    /**
     * Decompress the given compressed string back into the original string.
     * @param input The compressed string to decompress.
     */
    abstract decompress(input: string): Promise<string>;
  }

  export class DeflateCompressor extends StreamCompressor {
    get id(): string;
    protected get algorithm(): CompressionFormat;
    compress(input: string): Promise<string>;
    decompress(input: string): Promise<string>;
  }

  export class GzipCompressor extends StreamCompressor {
    get id(): string;
    protected get algorithm(): CompressionFormat;
  }

  export abstract class StreamCompressor extends CompressorBase {
    protected abstract get algorithm(): CompressionFormat;
    compress(input: string): Promise<string>;
    decompress(input: string): Promise<string>;
  }

  export class SerializerV0 extends SerializerBase {
    readonly version = 0;
    stringifyTile(tile: TileData): string;
    parseTile(str: string): TileData;
    stringifyConfig(instruction: Instruction, config: AnyConfig): string;
    parseConfig(
      configs: readonly AnyConfig[],
      entry: string
    ): [string, unknown];
    stringifyInstruction(instruction: Instruction): string;
    stringifyRule(rule: Rule): string;
    stringifySymbol(symbol: Symbol): string;
    parseRule(str: string): Rule;
    parseSymbol(str: string): Symbol;
    stringifyConnections(connections: GridConnections): string;
    parseConnections(input: string): GridConnections;
    stringifyTiles(tiles: readonly (readonly TileData[])[]): string;
    parseTiles(input: string): TileData[][];
    stringifyRules(rules: readonly Rule[]): string;
    parseRules(input: string): Rule[];
    stringifySymbols(symbols: ReadonlyMap<string, readonly Symbol[]>): string;
    parseSymbols(input: string): Map<string, Symbol[]>;
    stringifyGrid(grid: GridData): string;
    parseGrid(input: string): GridData;
    stringifyPuzzle(puzzle: Puzzle): string;
    parsePuzzle(input: string): Puzzle;
  }

  export abstract class SerializerBase {
    abstract get version(): number;
    abstract stringifyTile(tile: TileData): string;
    abstract parseTile(str: string): TileData;
    abstract stringifyRule(rule: Rule): string;
    abstract stringifySymbol(symbol: Symbol): string;
    abstract parseRule(str: string): Rule;
    abstract parseSymbol(str: string): Symbol;
    abstract stringifyConnections(connections: GridConnections): string;
    abstract parseConnections(input: string): GridConnections;
    abstract stringifyTiles(tiles: readonly (readonly TileData[])[]): string;
    abstract parseTiles(input: string): TileData[][];
    abstract stringifyRules(rules: readonly Rule[]): string;
    abstract parseRules(input: string): Rule[];
    abstract stringifySymbols(
      symbols: ReadonlyMap<string, readonly Symbol[]>
    ): string;
    abstract parseSymbols(input: string): Map<string, Symbol[]>;
    abstract stringifyGrid(grid: GridData): string;
    abstract parseGrid(input: string): GridData;
    abstract stringifyPuzzle(puzzle: Puzzle): string;
    abstract parsePuzzle(input: string): Puzzle;
  }

  export interface ShapeElement {
    x: number;
    y: number;
    color: Color;
  }
  export interface Shape {
    width: number;
    height: number;
    elements: ShapeElement[];
  }
  export function shapeEquals(a: Shape, b: Shape): boolean;
  export function tilesToShape(tiles: readonly (readonly TileData[])[]): Shape;
  export function positionsToShape(positions: Position[], color: Color): Shape;
  export function getShapeVariants(shape: Shape): Shape[];
  export function normalizeShape(shape: Shape): Shape;

  const allSolvers: Map<string, Solver>;
  export { allSolvers };

  export class BacktrackSolver extends Solver {
    readonly id = 'backtrack';
    readonly description =
      'Solves puzzles using backtracking relatively faster. Support all rules and symbols except for underclued.';
    solve(grid: GridData): AsyncGenerator<GridData | null>;
    isValid(grid: GridData): boolean;
    nextCell(grid: GridData): {
      x: number;
      y: number;
    } | null;
    backtrack(grid: GridData): GridData | null;
  }

  /**
   * Base class that all solvers must extend.
   */
  export abstract class Solver {
    /**
     * The unique identifier of the solver.
     *
     * This is also displayed to the user when selecting a solver.
     */
    abstract get id(): string;
    /**
     * A short paragraph describing when the user should use this solver.
     */
    abstract get description(): string;
    /**
     * Solve the given grid. The implementation should delegate long-running tasks to a worker thread and yield solutions
     * asynchronously.
     *
     * The solver must yield at least once, otherwise the UI will not update.
     *
     * If the solver finds no solution other than those already yielded, it should yield `null`. Yielding `null` on the
     * first iteration indicates that the grid is unsolvable. Yielding `null` on the second iteration indicates that the
     * solution is unique.
     *
     * In the current UI implementation, the solver will be terminated after yielding `null`, or after 2 iterations if
     * `null` is never yielded. The solver should perform any necessary cleanup in the `finally` block of the generator.
     *
     * @param grid The grid to solve. The provided grid is guaranteed to be supported by the solver. Some tiles in the
     * grid may already be filled by the user. It is up to the solver to decide whether to respect these tiles or not.
     */
    abstract solve(grid: GridData): AsyncGenerator<GridData | null>;
    /**
     * Check if the solver supports the current browser environment. This method is called once when the user first clicks
     * the "Solve" button, and the result is cached for the duration of the editor session.
     *
     * The `solve` method will not be called if this method returns `false`, and a message will be displayed to the user
     * indicating that the solver is not supported.
     *
     * @returns A promise that resolves to `true` if the environment is supported, or `false` otherwise.
     */
    isEnvironmentSupported(): Promise<boolean>;
    /**
     * Check if the solver supports the given instruction. This is used to render a small indication in the UI for each
     * instruction in the editor.
     *
     * @param instructionId The unique identifier of the instruction.
     */
    isInstructionSupported(instructionId: string): boolean;
    /**
     * Check if the solver supports the given grid. This methid is frequently called when the user changes the grid, and
     * the result is used to enable or disable the "Solve" button.
     *
     * The `solve` method will not be called if this method returns `false`, and a message will be displayed to the user
     * indicating that the grid is not supported by this solver.
     *
     * @param grid The grid to check.
     * @returns `true` if the grid is supported, or `false` otherwise.
     */
    isGridSupported(grid: GridData): boolean;
  }

  export abstract class SolverBase {
    abstract get id(): string;
    abstract solve(grid: GridData): AsyncGenerator<GridData | null>;
    isEnvironmentSupported(): Promise<boolean>;
    abstract isInstructionSupported(instructionId: string): boolean;
    isGridSupported(grid: GridData): boolean;
  }

  export class UndercluedSolver extends Solver {
    readonly id = 'underclued';
    readonly description =
      'Solves every puzzle as if it were underclued. Supports all rules and symbols and is decently fast for small puzzles. Very slow for large puzzles.';
    solve(grid: GridData): AsyncGenerator<GridData | null>;
    isInstructionSupported(instructionId: string): boolean;
  }

  const Worker: new (options?: { name?: string }) => Worker;
  export const Worker;

  export class AreaNumberModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export class CellCountModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export class ConnectAllModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export class DartModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  const allZ3Modules: Map<string, Z3Module>;
  export { allZ3Modules };

  export class LetterModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export class MyopiaModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export class RegionAreaModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export class ViewpointModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver<Name> | Optimize<Name>>
    ): void;
  }

  export abstract class Z3Module {
    abstract get id(): string;
    abstract encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name>
    ): void;
  }

  export function convertDirection(
    direction: Orientation | Direction
  ): import('grilops').Direction;

  export class Z3Solver extends Solver {
    readonly id = 'z3';
    readonly description =
      'Good for confirming that a solution is unique, especially for larger puzzles. It is otherwise slower than most solvers in small to medium-sized puzzles.';
    isEnvironmentSupported(): Promise<boolean>;
    solve(grid: GridData): AsyncGenerator<GridData | null>;
    isInstructionSupported(instructionId: string): boolean;
    isGridSupported(grid: GridData): boolean;
  }

  export class Z3SolverContext<
    Name extends string,
    const Core extends Solver<Name> | Optimize<Name> =
      | Solver<Name>
      | Optimize<Name>,
  > {
    readonly grid: SymbolGrid<Name, Core>;
    constructor(grid: SymbolGrid<Name, Core>);
    get solver(): Core;
    get lattice(): import('grilops').Lattice;
    get symbolSet(): import('grilops').SymbolSet;
    get ctx(): import('z3-solver').Context<Name>;
    get z3(): {
      mk_context: (
        c: import('z3-solver').Z3_config
      ) => import('z3-solver').Z3_context;
      mk_context_rc: (
        c: import('z3-solver').Z3_config
      ) => import('z3-solver').Z3_context;
      global_param_set: (param_id: string, param_value: string) => void;
      global_param_reset_all: () => void;
      global_param_get: (param_id: string) => string | null;
      mk_config: () => import('z3-solver').Z3_config;
      del_config: (c: import('z3-solver').Z3_config) => void;
      set_param_value: (
        c: import('z3-solver').Z3_config,
        param_id: string,
        param_value: string
      ) => void;
      del_context: (c: import('z3-solver').Z3_context) => void;
      inc_ref: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => void;
      dec_ref: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => void;
      update_param_value: (
        c: import('z3-solver').Z3_context,
        param_id: string,
        param_value: string
      ) => void;
      get_global_param_descrs: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_param_descrs;
      interrupt: (c: import('z3-solver').Z3_context) => void;
      enable_concurrent_dec_ref: (c: import('z3-solver').Z3_context) => void;
      mk_params: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_params;
      params_inc_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params
      ) => void;
      params_dec_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params
      ) => void;
      params_set_bool: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: boolean
      ) => void;
      params_set_uint: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: number
      ) => void;
      params_set_double: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: number
      ) => void;
      params_set_symbol: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: import('z3-solver').Z3_symbol
      ) => void;
      params_to_string: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params
      ) => string;
      params_validate: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        d: import('z3-solver').Z3_param_descrs
      ) => void;
      param_descrs_inc_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => void;
      param_descrs_dec_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => void;
      param_descrs_get_kind: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs,
        n: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_param_kind;
      param_descrs_size: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => number;
      param_descrs_get_name: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs,
        i: number
      ) => import('z3-solver').Z3_symbol;
      param_descrs_get_documentation: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs,
        s: import('z3-solver').Z3_symbol
      ) => string;
      param_descrs_to_string: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => string;
      mk_int_symbol: (
        c: import('z3-solver').Z3_context,
        i: number
      ) => import('z3-solver').Z3_symbol;
      mk_string_symbol: (
        c: import('z3-solver').Z3_context,
        s: string
      ) => import('z3-solver').Z3_symbol;
      mk_uninterpreted_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_sort;
      mk_type_variable: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_sort;
      mk_bool_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_int_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_real_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_bv_sort: (
        c: import('z3-solver').Z3_context,
        sz: number
      ) => import('z3-solver').Z3_sort;
      mk_finite_domain_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        size: bigint
      ) => import('z3-solver').Z3_sort;
      mk_array_sort: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort,
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_array_sort_n: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_tuple_sort: (
        c: import('z3-solver').Z3_context,
        mk_tuple_name: import('z3-solver').Z3_symbol,
        field_names: import('z3-solver').Z3_symbol[],
        field_sorts: import('z3-solver').Z3_sort[]
      ) => {
        rv: import('z3-solver').Z3_sort;
        mk_tuple_decl: import('z3-solver').Z3_func_decl;
        proj_decl: import('z3-solver').Z3_func_decl[];
      };
      mk_enumeration_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        enum_names: import('z3-solver').Z3_symbol[]
      ) => {
        rv: import('z3-solver').Z3_sort;
        enum_consts: import('z3-solver').Z3_func_decl[];
        enum_testers: import('z3-solver').Z3_func_decl[];
      };
      mk_list_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        elem_sort: import('z3-solver').Z3_sort
      ) => {
        rv: import('z3-solver').Z3_sort;
        nil_decl: import('z3-solver').Z3_func_decl;
        is_nil_decl: import('z3-solver').Z3_func_decl;
        cons_decl: import('z3-solver').Z3_func_decl;
        is_cons_decl: import('z3-solver').Z3_func_decl;
        head_decl: import('z3-solver').Z3_func_decl;
        tail_decl: import('z3-solver').Z3_func_decl;
      };
      mk_constructor: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        recognizer: import('z3-solver').Z3_symbol,
        field_names: import('z3-solver').Z3_symbol[],
        sorts: (import('z3-solver').Z3_sort | null)[],
        sort_refs: number[]
      ) => import('z3-solver').Z3_constructor;
      constructor_num_fields: (
        c: import('z3-solver').Z3_context,
        constr: import('z3-solver').Z3_constructor
      ) => number;
      del_constructor: (
        c: import('z3-solver').Z3_context,
        constr: import('z3-solver').Z3_constructor
      ) => void;
      mk_datatype: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        constructors: import('z3-solver').Z3_constructor[]
      ) => import('z3-solver').Z3_sort;
      mk_datatype_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_sort;
      mk_constructor_list: (
        c: import('z3-solver').Z3_context,
        constructors: import('z3-solver').Z3_constructor[]
      ) => import('z3-solver').Z3_constructor_list;
      del_constructor_list: (
        c: import('z3-solver').Z3_context,
        clist: import('z3-solver').Z3_constructor_list
      ) => void;
      mk_datatypes: (
        c: import('z3-solver').Z3_context,
        sort_names: import('z3-solver').Z3_symbol[],
        constructor_lists: import('z3-solver').Z3_constructor_list[]
      ) => import('z3-solver').Z3_sort[];
      query_constructor: (
        c: import('z3-solver').Z3_context,
        constr: import('z3-solver').Z3_constructor,
        num_fields: number
      ) => {
        constructor: import('z3-solver').Z3_func_decl;
        tester: import('z3-solver').Z3_func_decl;
        accessors: import('z3-solver').Z3_func_decl[];
      };
      mk_func_decl: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      mk_app: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_const: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fresh_func_decl: (
        c: import('z3-solver').Z3_context,
        prefix: string,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      mk_fresh_const: (
        c: import('z3-solver').Z3_context,
        prefix: string,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_rec_func_decl: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      add_rec_def: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl,
        args: import('z3-solver').Z3_ast[],
        body: import('z3-solver').Z3_ast
      ) => void;
      mk_true: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_false: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_eq: (
        c: import('z3-solver').Z3_context,
        l: import('z3-solver').Z3_ast,
        r: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_distinct: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_not: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ite: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        t3: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_iff: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_implies: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_xor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_and: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_or: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_add: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_mul: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_sub: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_unary_minus: (
        c: import('z3-solver').Z3_context,
        arg: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_div: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_mod: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_rem: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_power: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_lt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_le: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_gt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ge: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_divides: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_int2real: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_real2int: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_is_int: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvnot: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvredand: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvredor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvand: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvxor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvnand: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvnor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvxnor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvneg: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvadd: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsub: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvmul: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvudiv: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsdiv: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvurem: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsrem: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsmod: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvult: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvslt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvule: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsle: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvuge: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsge: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvugt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsgt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_concat: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_extract: (
        c: import('z3-solver').Z3_context,
        high: number,
        low: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_sign_ext: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_zero_ext: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_repeat: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bit2bool: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvshl: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvlshr: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvashr: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_rotate_left: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_rotate_right: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ext_rotate_left: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ext_rotate_right: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_int2bv: (
        c: import('z3-solver').Z3_context,
        n: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bv2int: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvadd_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvadd_no_underflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsub_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsub_no_underflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvsdiv_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvneg_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvmul_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvmul_no_underflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_select: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_select_n: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        idxs: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_store: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: import('z3-solver').Z3_ast,
        v: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_store_n: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        idxs: import('z3-solver').Z3_ast[],
        v: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_const_array: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort,
        v: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_map: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_array_default: (
        c: import('z3-solver').Z3_context,
        array: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_as_array: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      mk_set_has_size: (
        c: import('z3-solver').Z3_context,
        set: import('z3-solver').Z3_ast,
        k: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_sort: (
        c: import('z3-solver').Z3_context,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_empty_set: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_full_set: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_set_add: (
        c: import('z3-solver').Z3_context,
        set: import('z3-solver').Z3_ast,
        elem: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_del: (
        c: import('z3-solver').Z3_context,
        set: import('z3-solver').Z3_ast,
        elem: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_union: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_set_intersect: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_set_difference: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_complement: (
        c: import('z3-solver').Z3_context,
        arg: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_member: (
        c: import('z3-solver').Z3_context,
        elem: import('z3-solver').Z3_ast,
        set: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_subset: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_array_ext: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_numeral: (
        c: import('z3-solver').Z3_context,
        numeral: string,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_real: (
        c: import('z3-solver').Z3_context,
        num: number,
        den: number
      ) => import('z3-solver').Z3_ast;
      mk_real_int64: (
        c: import('z3-solver').Z3_context,
        num: bigint,
        den: bigint
      ) => import('z3-solver').Z3_ast;
      mk_int: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_unsigned_int: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_int64: (
        c: import('z3-solver').Z3_context,
        v: bigint,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_unsigned_int64: (
        c: import('z3-solver').Z3_context,
        v: bigint,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_bv_numeral: (
        c: import('z3-solver').Z3_context,
        bits: boolean[]
      ) => import('z3-solver').Z3_ast;
      mk_seq_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      is_seq_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      get_seq_sort_basis: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_re_sort: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      is_re_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      get_re_sort_basis: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_string_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_char_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      is_string_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      is_char_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      mk_string: (
        c: import('z3-solver').Z3_context,
        s: string
      ) => import('z3-solver').Z3_ast;
      mk_lstring: (
        c: import('z3-solver').Z3_context,
        len: number,
        s: string
      ) => import('z3-solver').Z3_ast;
      mk_u32string: (
        c: import('z3-solver').Z3_context,
        chars: number[]
      ) => import('z3-solver').Z3_ast;
      is_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => boolean;
      get_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => string;
      get_string_length: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => number;
      get_string_contents: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        length: number
      ) => number[];
      mk_seq_empty: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_seq_unit: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_concat: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_seq_prefix: (
        c: import('z3-solver').Z3_context,
        prefix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_suffix: (
        c: import('z3-solver').Z3_context,
        suffix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_contains: (
        c: import('z3-solver').Z3_context,
        container: import('z3-solver').Z3_ast,
        containee: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_str_lt: (
        c: import('z3-solver').Z3_context,
        prefix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_str_le: (
        c: import('z3-solver').Z3_context,
        prefix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_extract: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        offset: import('z3-solver').Z3_ast,
        length: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_replace: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        src: import('z3-solver').Z3_ast,
        dst: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_at: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        index: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_nth: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        index: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_length: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_index: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        substr: import('z3-solver').Z3_ast,
        offset: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_last_index: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        substr: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_str_to_int: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_int_to_str: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_string_to_code: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_string_from_code: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ubv_to_str: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_sbv_to_str: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_to_re: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_in_re: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_ast,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_plus: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_star: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_option: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_union: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_re_concat: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_re_range: (
        c: import('z3-solver').Z3_context,
        lo: import('z3-solver').Z3_ast,
        hi: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_allchar: (
        c: import('z3-solver').Z3_context,
        regex_sort: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_re_loop: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_ast,
        lo: number,
        hi: number
      ) => import('z3-solver').Z3_ast;
      mk_re_power: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast,
        n: number
      ) => import('z3-solver').Z3_ast;
      mk_re_intersect: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_re_complement: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_diff: (
        c: import('z3-solver').Z3_context,
        re1: import('z3-solver').Z3_ast,
        re2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_empty: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_re_full: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_char: (
        c: import('z3-solver').Z3_context,
        ch: number
      ) => import('z3-solver').Z3_ast;
      mk_char_le: (
        c: import('z3-solver').Z3_context,
        ch1: import('z3-solver').Z3_ast,
        ch2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_to_int: (
        c: import('z3-solver').Z3_context,
        ch: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_to_bv: (
        c: import('z3-solver').Z3_context,
        ch: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_from_bv: (
        c: import('z3-solver').Z3_context,
        bv: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_is_digit: (
        c: import('z3-solver').Z3_context,
        ch: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_linear_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_partial_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_piecewise_linear_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_tree_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_transitive_closure: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_func_decl;
      mk_pattern: (
        c: import('z3-solver').Z3_context,
        terms: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_pattern;
      mk_bound: (
        c: import('z3-solver').Z3_context,
        index: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_forall: (
        c: import('z3-solver').Z3_context,
        weight: number,
        patterns: import('z3-solver').Z3_pattern[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_exists: (
        c: import('z3-solver').Z3_context,
        weight: number,
        patterns: import('z3-solver').Z3_pattern[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        patterns: import('z3-solver').Z3_pattern[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier_ex: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        quantifier_id: import('z3-solver').Z3_symbol,
        skolem_id: import('z3-solver').Z3_symbol,
        patterns: import('z3-solver').Z3_pattern[],
        no_patterns: import('z3-solver').Z3_ast[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_forall_const: (
        c: import('z3-solver').Z3_context,
        weight: number,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_exists_const: (
        c: import('z3-solver').Z3_context,
        weight: number,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier_const: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier_const_ex: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        quantifier_id: import('z3-solver').Z3_symbol,
        skolem_id: import('z3-solver').Z3_symbol,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        no_patterns: import('z3-solver').Z3_ast[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_lambda: (
        c: import('z3-solver').Z3_context,
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_lambda_const: (
        c: import('z3-solver').Z3_context,
        bound: import('z3-solver').Z3_app[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_symbol_kind: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_symbol_kind;
      get_symbol_int: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => number;
      get_symbol_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => string;
      get_sort_name: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_symbol;
      get_sort_id: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      sort_to_ast: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      is_eq_sort: (
        c: import('z3-solver').Z3_context,
        s1: import('z3-solver').Z3_sort,
        s2: import('z3-solver').Z3_sort
      ) => boolean;
      get_sort_kind: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort_kind;
      get_bv_sort_size: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => number;
      get_finite_domain_sort_size: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => bigint | null;
      get_array_sort_domain: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      get_array_sort_domain_n: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx: number
      ) => import('z3-solver').Z3_sort;
      get_array_sort_range: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      get_tuple_sort_mk_decl: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      get_tuple_sort_num_fields: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => number;
      get_tuple_sort_field_decl: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        i: number
      ) => import('z3-solver').Z3_func_decl;
      get_datatype_sort_num_constructors: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => number;
      get_datatype_sort_constructor: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx: number
      ) => import('z3-solver').Z3_func_decl;
      get_datatype_sort_recognizer: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx: number
      ) => import('z3-solver').Z3_func_decl;
      get_datatype_sort_constructor_accessor: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx_c: number,
        idx_a: number
      ) => import('z3-solver').Z3_func_decl;
      datatype_update_field: (
        c: import('z3-solver').Z3_context,
        field_access: import('z3-solver').Z3_func_decl,
        t: import('z3-solver').Z3_ast,
        value: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_relation_arity: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      get_relation_column: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort,
        col: number
      ) => import('z3-solver').Z3_sort;
      mk_atmost: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_atleast: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_pble: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        coeffs: number[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_pbge: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        coeffs: number[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_pbeq: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        coeffs: number[],
        k: number
      ) => import('z3-solver').Z3_ast;
      func_decl_to_ast: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      is_eq_func_decl: (
        c: import('z3-solver').Z3_context,
        f1: import('z3-solver').Z3_func_decl,
        f2: import('z3-solver').Z3_func_decl
      ) => boolean;
      get_func_decl_id: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => number;
      get_decl_name: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_symbol;
      get_decl_kind: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_decl_kind;
      get_domain_size: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => number;
      get_arity: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => number;
      get_domain: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        i: number
      ) => import('z3-solver').Z3_sort;
      get_range: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_sort;
      get_decl_num_parameters: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => number;
      get_decl_parameter_kind: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_parameter_kind;
      get_decl_int_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => number;
      get_decl_double_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => number;
      get_decl_symbol_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_symbol;
      get_decl_sort_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_sort;
      get_decl_ast_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_ast;
      get_decl_func_decl_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_func_decl;
      get_decl_rational_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => string;
      app_to_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app
      ) => import('z3-solver').Z3_ast;
      get_app_decl: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app
      ) => import('z3-solver').Z3_func_decl;
      get_app_num_args: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app
      ) => number;
      get_app_arg: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app,
        i: number
      ) => import('z3-solver').Z3_ast;
      is_eq_ast: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => boolean;
      get_ast_id: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => number;
      get_ast_hash: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_sort: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_sort;
      is_well_sorted: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      get_bool_value: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_lbool;
      get_ast_kind: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast_kind;
      is_app: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_numeral_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_algebraic_number: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      to_app: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_app;
      to_func_decl: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_func_decl;
      get_numeral_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => string;
      get_numeral_binary_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => string;
      get_numeral_decimal_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        precision: number
      ) => string;
      get_numeral_double: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_numerator: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_denominator: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_numeral_small: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => {
        num: bigint;
        den: bigint;
      } | null;
      get_numeral_int: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => number | null;
      get_numeral_uint: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => number | null;
      get_numeral_uint64: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => bigint | null;
      get_numeral_int64: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => bigint | null;
      get_numeral_rational_int64: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => {
        num: bigint;
        den: bigint;
      } | null;
      get_algebraic_number_lower: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        precision: number
      ) => import('z3-solver').Z3_ast;
      get_algebraic_number_upper: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        precision: number
      ) => import('z3-solver').Z3_ast;
      pattern_to_ast: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern
      ) => import('z3-solver').Z3_ast;
      get_pattern_num_terms: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern
      ) => number;
      get_pattern: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern,
        idx: number
      ) => import('z3-solver').Z3_ast;
      get_index_value: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      is_quantifier_forall: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_quantifier_exists: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_lambda: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      get_quantifier_weight: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_skolem_id: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_symbol;
      get_quantifier_id: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_symbol;
      get_quantifier_num_patterns: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_pattern_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_pattern;
      get_quantifier_num_no_patterns: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_no_pattern_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_ast;
      get_quantifier_num_bound: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_bound_name: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_symbol;
      get_quantifier_bound_sort: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_sort;
      get_quantifier_body: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      simplify: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => Promise<import('z3-solver').Z3_ast>;
      simplify_ex: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        p: import('z3-solver').Z3_params
      ) => Promise<import('z3-solver').Z3_ast>;
      simplify_get_help: (c: import('z3-solver').Z3_context) => string;
      simplify_get_param_descrs: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_param_descrs;
      update_term: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      substitute: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        from: import('z3-solver').Z3_ast[],
        to: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      substitute_vars: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        to: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      substitute_funs: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        from: import('z3-solver').Z3_func_decl[],
        to: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      translate: (
        source: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        target: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_model: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_model;
      model_inc_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => void;
      model_dec_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => void;
      model_eval: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        t: import('z3-solver').Z3_ast,
        model_completion: boolean
      ) => import('z3-solver').Z3_ast | null;
      model_get_const_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        a: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast | null;
      model_has_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        a: import('z3-solver').Z3_func_decl
      ) => boolean;
      model_get_func_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_func_interp | null;
      model_get_num_consts: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => number;
      model_get_const_decl: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        i: number
      ) => import('z3-solver').Z3_func_decl;
      model_get_num_funcs: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => number;
      model_get_func_decl: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        i: number
      ) => import('z3-solver').Z3_func_decl;
      model_get_num_sorts: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => number;
      model_get_sort: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        i: number
      ) => import('z3-solver').Z3_sort;
      model_get_sort_universe: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast_vector;
      model_translate: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        dst: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_model;
      is_as_array: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      get_as_array_func_decl: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_func_decl;
      add_func_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        f: import('z3-solver').Z3_func_decl,
        default_value: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_func_interp;
      add_const_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        f: import('z3-solver').Z3_func_decl,
        a: import('z3-solver').Z3_ast
      ) => void;
      func_interp_inc_ref: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => void;
      func_interp_dec_ref: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => void;
      func_interp_get_num_entries: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => number;
      func_interp_get_entry: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp,
        i: number
      ) => import('z3-solver').Z3_func_entry;
      func_interp_get_else: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => import('z3-solver').Z3_ast;
      func_interp_set_else: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp,
        else_value: import('z3-solver').Z3_ast
      ) => void;
      func_interp_get_arity: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => number;
      func_interp_add_entry: (
        c: import('z3-solver').Z3_context,
        fi: import('z3-solver').Z3_func_interp,
        args: import('z3-solver').Z3_ast_vector,
        value: import('z3-solver').Z3_ast
      ) => void;
      func_entry_inc_ref: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => void;
      func_entry_dec_ref: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => void;
      func_entry_get_value: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => import('z3-solver').Z3_ast;
      func_entry_get_num_args: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => number;
      func_entry_get_arg: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry,
        i: number
      ) => import('z3-solver').Z3_ast;
      open_log: (filename: string) => boolean;
      append_log: (string: string) => void;
      close_log: () => void;
      toggle_warning_messages: (enabled: boolean) => void;
      set_ast_print_mode: (
        c: import('z3-solver').Z3_context,
        mode: import('z3-solver').Z3_ast_print_mode
      ) => void;
      ast_to_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => string;
      pattern_to_string: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern
      ) => string;
      sort_to_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => string;
      func_decl_to_string: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => string;
      model_to_string: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => string;
      benchmark_to_smtlib_string: (
        c: import('z3-solver').Z3_context,
        name: string,
        logic: string,
        status: string,
        attributes: string,
        assumptions: import('z3-solver').Z3_ast[],
        formula: import('z3-solver').Z3_ast
      ) => string;
      parse_smtlib2_string: (
        c: import('z3-solver').Z3_context,
        str: string,
        sort_names: import('z3-solver').Z3_symbol[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        decls: import('z3-solver').Z3_func_decl[]
      ) => import('z3-solver').Z3_ast_vector;
      parse_smtlib2_file: (
        c: import('z3-solver').Z3_context,
        file_name: string,
        sort_names: import('z3-solver').Z3_symbol[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        decls: import('z3-solver').Z3_func_decl[]
      ) => import('z3-solver').Z3_ast_vector;
      eval_smtlib2_string: (
        c: import('z3-solver').Z3_context,
        str: string
      ) => Promise<string>;
      mk_parser_context: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_parser_context;
      parser_context_inc_ref: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context
      ) => void;
      parser_context_dec_ref: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context
      ) => void;
      parser_context_add_sort: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context,
        s: import('z3-solver').Z3_sort
      ) => void;
      parser_context_add_decl: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context,
        f: import('z3-solver').Z3_func_decl
      ) => void;
      parser_context_from_string: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context,
        s: string
      ) => import('z3-solver').Z3_ast_vector;
      get_error_code: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_error_code;
      set_error: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_error_code
      ) => void;
      get_error_msg: (
        c: import('z3-solver').Z3_context,
        err: import('z3-solver').Z3_error_code
      ) => string;
      get_version: () => {
        major: number;
        minor: number;
        build_number: number;
        revision_number: number;
      };
      get_full_version: () => string;
      enable_trace: (tag: string) => void;
      disable_trace: (tag: string) => void;
      reset_memory: () => void;
      finalize_memory: () => void;
      mk_goal: (
        c: import('z3-solver').Z3_context,
        models: boolean,
        unsat_cores: boolean,
        proofs: boolean
      ) => import('z3-solver').Z3_goal;
      goal_inc_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => void;
      goal_dec_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => void;
      goal_precision: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => import('z3-solver').Z3_goal_prec;
      goal_assert: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        a: import('z3-solver').Z3_ast
      ) => void;
      goal_inconsistent: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => boolean;
      goal_depth: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => number;
      goal_reset: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => void;
      goal_size: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => number;
      goal_formula: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        idx: number
      ) => import('z3-solver').Z3_ast;
      goal_num_exprs: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => number;
      goal_is_decided_sat: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => boolean;
      goal_is_decided_unsat: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => boolean;
      goal_translate: (
        source: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        target: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_goal;
      goal_convert_model: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        m: import('z3-solver').Z3_model
      ) => import('z3-solver').Z3_model;
      goal_to_string: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => string;
      goal_to_dimacs_string: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        include_names: boolean
      ) => string;
      mk_tactic: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => import('z3-solver').Z3_tactic;
      tactic_inc_ref: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => void;
      tactic_dec_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_tactic
      ) => void;
      mk_probe: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => import('z3-solver').Z3_probe;
      probe_inc_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => void;
      probe_dec_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => void;
      tactic_and_then: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_or_else: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_par_or: (
        c: import('z3-solver').Z3_context,
        ts: import('z3-solver').Z3_tactic[]
      ) => import('z3-solver').Z3_tactic;
      tactic_par_and_then: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_try_for: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        ms: number
      ) => import('z3-solver').Z3_tactic;
      tactic_when: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe,
        t: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_cond: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_repeat: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        max: number
      ) => import('z3-solver').Z3_tactic;
      tactic_skip: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_tactic;
      tactic_fail: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_tactic;
      tactic_fail_if: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_tactic;
      tactic_fail_if_not_decided: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_tactic;
      tactic_using_params: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        p: import('z3-solver').Z3_params
      ) => import('z3-solver').Z3_tactic;
      mk_simplifier: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => import('z3-solver').Z3_simplifier;
      simplifier_inc_ref: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier
      ) => void;
      simplifier_dec_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_simplifier
      ) => void;
      solver_add_simplifier: (
        c: import('z3-solver').Z3_context,
        solver: import('z3-solver').Z3_solver,
        simplifier: import('z3-solver').Z3_simplifier
      ) => import('z3-solver').Z3_solver;
      simplifier_and_then: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_simplifier,
        t2: import('z3-solver').Z3_simplifier
      ) => import('z3-solver').Z3_simplifier;
      simplifier_using_params: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier,
        p: import('z3-solver').Z3_params
      ) => import('z3-solver').Z3_simplifier;
      get_num_simplifiers: (c: import('z3-solver').Z3_context) => number;
      get_simplifier_name: (
        c: import('z3-solver').Z3_context,
        i: number
      ) => string;
      simplifier_get_help: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier
      ) => string;
      simplifier_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier
      ) => import('z3-solver').Z3_param_descrs;
      simplifier_get_descr: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => string;
      probe_const: (
        x: import('z3-solver').Z3_context,
        val: number
      ) => import('z3-solver').Z3_probe;
      probe_lt: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_gt: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_le: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_ge: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_eq: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_and: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_or: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_not: (
        x: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      get_num_tactics: (c: import('z3-solver').Z3_context) => number;
      get_tactic_name: (c: import('z3-solver').Z3_context, i: number) => string;
      get_num_probes: (c: import('z3-solver').Z3_context) => number;
      get_probe_name: (c: import('z3-solver').Z3_context, i: number) => string;
      tactic_get_help: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => string;
      tactic_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_param_descrs;
      tactic_get_descr: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => string;
      probe_get_descr: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => string;
      probe_apply: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe,
        g: import('z3-solver').Z3_goal
      ) => number;
      tactic_apply: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        g: import('z3-solver').Z3_goal
      ) => Promise<import('z3-solver').Z3_apply_result>;
      tactic_apply_ex: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        g: import('z3-solver').Z3_goal,
        p: import('z3-solver').Z3_params
      ) => Promise<import('z3-solver').Z3_apply_result>;
      apply_result_inc_ref: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => void;
      apply_result_dec_ref: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => void;
      apply_result_to_string: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => string;
      apply_result_get_num_subgoals: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => number;
      apply_result_get_subgoal: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result,
        i: number
      ) => import('z3-solver').Z3_goal;
      mk_solver: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_solver;
      mk_simple_solver: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_solver;
      mk_solver_for_logic: (
        c: import('z3-solver').Z3_context,
        logic: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_solver;
      mk_solver_from_tactic: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_solver;
      solver_translate: (
        source: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        target: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_solver;
      solver_import_model_converter: (
        ctx: import('z3-solver').Z3_context,
        src: import('z3-solver').Z3_solver,
        dst: import('z3-solver').Z3_solver
      ) => void;
      solver_get_help: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => string;
      solver_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_param_descrs;
      solver_set_params: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        p: import('z3-solver').Z3_params
      ) => void;
      solver_inc_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_dec_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_interrupt: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_push: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_pop: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        n: number
      ) => void;
      solver_reset: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_get_num_scopes: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => number;
      solver_assert: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast
      ) => void;
      solver_assert_and_track: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast,
        p: import('z3-solver').Z3_ast
      ) => void;
      solver_from_file: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        file_name: string
      ) => void;
      solver_from_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        file_name: string
      ) => void;
      solver_get_assertions: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_units: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_trail: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_non_units: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_levels: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        literals: import('z3-solver').Z3_ast_vector,
        levels: number[]
      ) => void;
      solver_congruence_root: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      solver_congruence_next: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      solver_next_split: (
        c: import('z3-solver').Z3_context,
        cb: import('z3-solver').Z3_solver_callback,
        t: import('z3-solver').Z3_ast,
        idx: number,
        phase: import('z3-solver').Z3_lbool
      ) => boolean;
      solver_propagate_declare: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      solver_propagate_register: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        e: import('z3-solver').Z3_ast
      ) => void;
      solver_propagate_register_cb: (
        c: import('z3-solver').Z3_context,
        cb: import('z3-solver').Z3_solver_callback,
        e: import('z3-solver').Z3_ast
      ) => void;
      solver_propagate_consequence: (
        c: import('z3-solver').Z3_context,
        cb: import('z3-solver').Z3_solver_callback,
        fixed: import('z3-solver').Z3_ast[],
        eq_lhs: import('z3-solver').Z3_ast[],
        eq_rhs: import('z3-solver').Z3_ast[],
        conseq: import('z3-solver').Z3_ast
      ) => boolean;
      solver_check: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => Promise<import('z3-solver').Z3_lbool>;
      solver_check_assumptions: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        assumptions: import('z3-solver').Z3_ast[]
      ) => Promise<import('z3-solver').Z3_lbool>;
      get_implied_equalities: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        terms: import('z3-solver').Z3_ast[]
      ) => {
        rv: import('z3-solver').Z3_lbool;
        class_ids: number[];
      };
      solver_get_consequences: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        assumptions: import('z3-solver').Z3_ast_vector,
        variables: import('z3-solver').Z3_ast_vector,
        consequences: import('z3-solver').Z3_ast_vector
      ) => Promise<import('z3-solver').Z3_lbool>;
      solver_cube: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        vars: import('z3-solver').Z3_ast_vector,
        backtrack_level: number
      ) => Promise<import('z3-solver').Z3_ast_vector>;
      solver_get_model: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_model;
      solver_get_proof: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast;
      solver_get_unsat_core: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_reason_unknown: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => string;
      solver_get_statistics: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_stats;
      solver_to_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => string;
      solver_to_dimacs_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        include_names: boolean
      ) => string;
      stats_to_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => string;
      stats_inc_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => void;
      stats_dec_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => void;
      stats_size: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => number;
      stats_get_key: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => string;
      stats_is_uint: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => boolean;
      stats_is_double: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => boolean;
      stats_get_uint_value: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => number;
      stats_get_double_value: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => number;
      get_estimated_alloc_size: () => bigint;
      algebraic_is_value: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_is_pos: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_is_neg: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_is_zero: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_sign: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      algebraic_add: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_sub: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_mul: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_div: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_root: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        k: number
      ) => import('z3-solver').Z3_ast;
      algebraic_power: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        k: number
      ) => import('z3-solver').Z3_ast;
      algebraic_lt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_gt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_le: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_ge: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_eq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_neq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_roots: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_ast,
        a: import('z3-solver').Z3_ast[]
      ) => Promise<import('z3-solver').Z3_ast_vector>;
      algebraic_eval: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_ast,
        a: import('z3-solver').Z3_ast[]
      ) => Promise<number>;
      algebraic_get_poly: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast_vector;
      algebraic_get_i: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      mk_ast_vector: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast_vector;
      ast_vector_inc_ref: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => void;
      ast_vector_dec_ref: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => void;
      ast_vector_size: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => number;
      ast_vector_get: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        i: number
      ) => import('z3-solver').Z3_ast;
      ast_vector_set: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        i: number,
        a: import('z3-solver').Z3_ast
      ) => void;
      ast_vector_resize: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        n: number
      ) => void;
      ast_vector_push: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        a: import('z3-solver').Z3_ast
      ) => void;
      ast_vector_translate: (
        s: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        t: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast_vector;
      ast_vector_to_string: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => string;
      mk_ast_map: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast_map;
      ast_map_inc_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => void;
      ast_map_dec_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => void;
      ast_map_contains: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast
      ) => boolean;
      ast_map_find: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      ast_map_insert: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast,
        v: import('z3-solver').Z3_ast
      ) => void;
      ast_map_erase: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast
      ) => void;
      ast_map_reset: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => void;
      ast_map_size: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => number;
      ast_map_keys: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => import('z3-solver').Z3_ast_vector;
      ast_map_to_string: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => string;
      mk_fixedpoint: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_fixedpoint;
      fixedpoint_inc_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => void;
      fixedpoint_dec_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => void;
      fixedpoint_add_rule: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        rule: import('z3-solver').Z3_ast,
        name: import('z3-solver').Z3_symbol
      ) => void;
      fixedpoint_add_fact: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        r: import('z3-solver').Z3_func_decl,
        args: number[]
      ) => void;
      fixedpoint_assert: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        axiom: import('z3-solver').Z3_ast
      ) => void;
      fixedpoint_query: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        query: import('z3-solver').Z3_ast
      ) => Promise<import('z3-solver').Z3_lbool>;
      fixedpoint_query_relations: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        relations: import('z3-solver').Z3_func_decl[]
      ) => Promise<import('z3-solver').Z3_lbool>;
      fixedpoint_get_answer: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast;
      fixedpoint_get_reason_unknown: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => string;
      fixedpoint_update_rule: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        a: import('z3-solver').Z3_ast,
        name: import('z3-solver').Z3_symbol
      ) => void;
      fixedpoint_get_num_levels: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        pred: import('z3-solver').Z3_func_decl
      ) => number;
      fixedpoint_get_cover_delta: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        level: number,
        pred: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      fixedpoint_add_cover: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        level: number,
        pred: import('z3-solver').Z3_func_decl,
        property: import('z3-solver').Z3_ast
      ) => void;
      fixedpoint_get_statistics: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_stats;
      fixedpoint_register_relation: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        f: import('z3-solver').Z3_func_decl
      ) => void;
      fixedpoint_set_predicate_representation: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        f: import('z3-solver').Z3_func_decl,
        relation_kinds: import('z3-solver').Z3_symbol[]
      ) => void;
      fixedpoint_get_rules: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_get_assertions: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_set_params: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        p: import('z3-solver').Z3_params
      ) => void;
      fixedpoint_get_help: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => string;
      fixedpoint_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_param_descrs;
      fixedpoint_to_string: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        queries: import('z3-solver').Z3_ast[]
      ) => string;
      fixedpoint_from_string: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        s: string
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_from_file: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        s: string
      ) => import('z3-solver').Z3_ast_vector;
      mk_fpa_rounding_mode_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_round_nearest_ties_to_even: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rne: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_nearest_ties_to_away: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rna: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_toward_positive: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rtp: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_toward_negative: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rtn: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_toward_zero: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rtz: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_sort: (
        c: import('z3-solver').Z3_context,
        ebits: number,
        sbits: number
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_half: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_16: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_single: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_32: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_double: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_64: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_quadruple: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_128: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_nan: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_inf: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort,
        negative: boolean
      ) => import('z3-solver').Z3_ast;
      mk_fpa_zero: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort,
        negative: boolean
      ) => import('z3-solver').Z3_ast;
      mk_fpa_fp: (
        c: import('z3-solver').Z3_context,
        sgn: import('z3-solver').Z3_ast,
        exp: import('z3-solver').Z3_ast,
        sig: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_float: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_double: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_int: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_int_uint: (
        c: import('z3-solver').Z3_context,
        sgn: boolean,
        exp: number,
        sig: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_int64_uint64: (
        c: import('z3-solver').Z3_context,
        sgn: boolean,
        exp: bigint,
        sig: bigint,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_abs: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_neg: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_add: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_sub: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_mul: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_div: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_fma: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        t3: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_sqrt: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rem: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_to_integral: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_min: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_max: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_leq: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_lt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_geq: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_gt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_eq: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_normal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_subnormal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_zero: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_infinite: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_nan: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_negative: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_positive: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_bv: (
        c: import('z3-solver').Z3_context,
        bv: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_float: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_real: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_signed: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_unsigned: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_ubv: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        sz: number
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_sbv: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        sz: number
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_real: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      fpa_get_ebits: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      fpa_get_sbits: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      fpa_is_numeral_nan: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_inf: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_zero: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_normal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_subnormal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_positive: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_negative: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_get_numeral_sign_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      fpa_get_numeral_significand_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      fpa_get_numeral_sign: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => number | null;
      fpa_get_numeral_significand_string: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => string;
      fpa_get_numeral_significand_uint64: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => bigint | null;
      fpa_get_numeral_exponent_string: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast,
        biased: boolean
      ) => string;
      fpa_get_numeral_exponent_int64: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast,
        biased: boolean
      ) => bigint | null;
      fpa_get_numeral_exponent_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast,
        biased: boolean
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_ieee_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_int_real: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        exp: import('z3-solver').Z3_ast,
        sig: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_optimize: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_optimize;
      optimize_inc_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_dec_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_assert: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        a: import('z3-solver').Z3_ast
      ) => void;
      optimize_assert_and_track: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        a: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast
      ) => void;
      optimize_assert_soft: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        a: import('z3-solver').Z3_ast,
        weight: string,
        id: import('z3-solver').Z3_symbol
      ) => number;
      optimize_maximize: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        t: import('z3-solver').Z3_ast
      ) => number;
      optimize_minimize: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        t: import('z3-solver').Z3_ast
      ) => number;
      optimize_push: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_pop: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_check: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        assumptions: import('z3-solver').Z3_ast[]
      ) => Promise<import('z3-solver').Z3_lbool>;
      optimize_get_reason_unknown: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => string;
      optimize_get_model: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_model;
      optimize_get_unsat_core: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_ast_vector;
      optimize_set_params: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        p: import('z3-solver').Z3_params
      ) => void;
      optimize_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_param_descrs;
      optimize_get_lower: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast;
      optimize_get_upper: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast;
      optimize_get_lower_as_vector: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast_vector;
      optimize_get_upper_as_vector: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast_vector;
      optimize_to_string: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => string;
      optimize_from_string: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        s: string
      ) => void;
      optimize_from_file: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        s: string
      ) => void;
      optimize_get_help: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_optimize
      ) => string;
      optimize_get_statistics: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_stats;
      optimize_get_assertions: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_ast_vector;
      optimize_get_objectives: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_ast_vector;
      polynomial_subresultants: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_ast,
        q: import('z3-solver').Z3_ast,
        x: import('z3-solver').Z3_ast
      ) => Promise<import('z3-solver').Z3_ast_vector>;
      rcf_del: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => void;
      rcf_mk_rational: (
        c: import('z3-solver').Z3_context,
        val: string
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_small_int: (
        c: import('z3-solver').Z3_context,
        val: number
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_pi: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_e: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_infinitesimal: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_roots: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num[]
      ) => {
        rv: number;
        roots: import('z3-solver').Z3_rcf_num[];
      };
      rcf_add: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_sub: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mul: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_div: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_neg: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_inv: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_power: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        k: number
      ) => import('z3-solver').Z3_rcf_num;
      rcf_lt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_gt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_le: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_ge: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_eq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_neq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_num_to_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        compact: boolean,
        html: boolean
      ) => string;
      rcf_num_to_decimal_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        prec: number
      ) => string;
      rcf_get_numerator_denominator: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => {
        n: import('z3-solver').Z3_rcf_num;
        d: import('z3-solver').Z3_rcf_num;
      };
      rcf_is_rational: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_is_algebraic: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_is_infinitesimal: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_is_transcendental: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_extension_index: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => number;
      rcf_transcendental_name: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_symbol;
      rcf_infinitesimal_name: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_symbol;
      rcf_num_coefficients: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => number;
      rcf_coefficient: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number
      ) => import('z3-solver').Z3_rcf_num;
      rcf_num_sign_conditions: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => number;
      rcf_sign_condition_sign: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number
      ) => number;
      rcf_num_sign_condition_coefficients: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number
      ) => number;
      rcf_sign_condition_coefficient: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number,
        j: number
      ) => import('z3-solver').Z3_rcf_num;
      fixedpoint_query_from_lvl: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        query: import('z3-solver').Z3_ast,
        lvl: number
      ) => Promise<import('z3-solver').Z3_lbool>;
      fixedpoint_get_ground_sat_answer: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast;
      fixedpoint_get_rules_along_trace: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_get_rule_names_along_trace: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_symbol;
      fixedpoint_add_invariant: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        pred: import('z3-solver').Z3_func_decl,
        property: import('z3-solver').Z3_ast
      ) => void;
      fixedpoint_get_reachable: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        pred: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      qe_model_project: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        bound: import('z3-solver').Z3_app[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      qe_model_project_skolem: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        bound: import('z3-solver').Z3_app[],
        body: import('z3-solver').Z3_ast,
        map: import('z3-solver').Z3_ast_map
      ) => import('z3-solver').Z3_ast;
      model_extrapolate: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        fml: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      qe_lite: (
        c: import('z3-solver').Z3_context,
        vars: import('z3-solver').Z3_ast_vector,
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
    };
    get regionConstrainer(): RegionConstrainer<Name, Core>;
  }

  export class AreaNumberSymbol extends NumberSymbol {
    /**
     * **Area Numbers must equal region sizes**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The area number.
     */
    constructor(x: number, y: number, number: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
    }: {
      x?: number;
      y?: number;
      number?: number;
    }): this;
    withNumber(number: number): this;
  }

  export type IconString = keyof typeof Md;
  export class CustomIconSymbol extends CustomSymbol {
    readonly icon: IconString;
    readonly rotation: number;
    /**
     * **A custom icon symbol**
     *
     * @param description - The description of the symbol. Leave this empty to hide the description.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param icon - The icon to display. All available icons can be found at https://react-icons.github.io/react-icons/icons/md/
     * @param rotation - The rotation of the icon in degrees.
     */
    constructor(
      description: string,
      grid: GridData,
      x: number,
      y: number,
      icon: IconString,
      rotation?: number
    );
    get id(): string;
    get configs(): readonly AnyConfig[] | null;
    copyWith({
      description,
      grid,
      x,
      y,
      icon,
      rotation,
    }: {
      description?: string;
      grid?: GridData;
      x?: number;
      y?: number;
      icon?: IconString;
      rotation?: number;
    }): this;
    withIcon(icon: IconString): this;
    withRotation(rotation: number): this;
  }

  export abstract class CustomSymbol extends MultiEntrySymbol {
    readonly description: string;
    readonly grid: GridData;
    /**
     * **A custom symbol**
     *
     * @param description - The description of the symbol. Leave this empty to hide the description.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     */
    constructor(description: string, grid: GridData, x: number, y: number);
    get explanation(): string;
    createExampleGrid(): GridData;
    validateSymbol(_grid: GridData): State;
    get validateWithSolution(): boolean;
    withDescription(description: string): this;
    withGrid(grid: GridData): this;
  }

  export class CustomTextSymbol extends CustomSymbol {
    readonly text: string;
    readonly rotation: number;
    /**
     * **A custom text symbol**
     *
     * @param description - The description of the symbol. Leave this empty to hide the description.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param text - The text to display.
     * @param rotation - The rotation of the text in degrees.
     */
    constructor(
      description: string,
      grid: GridData,
      x: number,
      y: number,
      text: string,
      rotation?: number
    );
    get id(): string;
    get configs(): readonly AnyConfig[] | null;
    copyWith({
      description,
      grid,
      x,
      y,
      text,
      rotation,
    }: {
      description?: string;
      grid?: GridData;
      x?: number;
      y?: number;
      text?: string;
      rotation?: number;
    }): this;
    withText(text: string): this;
    withRotation(rotation: number): this;
  }

  export class DartSymbol extends NumberSymbol {
    readonly orientation: Orientation;
    /**
     * **Darts count opposite color cells in that direction**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The number of cells seen by the symbol.
     * @param orientation - The orientation of the symbol.
     */
    constructor(x: number, y: number, number: number, orientation: Orientation);
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
      orientation,
    }: {
      x?: number;
      y?: number;
      number?: number;
      orientation?: Orientation;
    }): this;
    withNumber(number: number): this;
  }

  export type DirectionLinkerMap = {
    [key in Direction]: Direction;
  };
  export class DirectionLinkerSymbol extends Symbol {
    readonly x: number;
    readonly y: number;
    /**
     * **Darts count opposite color cells in that direction**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     */
    constructor(x: number, y: number);
    changeDirections(linkedDirections: DirectionLinkerMap): this;
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({ x, y }: { x?: number; y?: number }): this;
  }

  export class GalaxySymbol extends DirectionLinkerSymbol {
    readonly x: number;
    readonly y: number;
    /**
     * **Galaxies are centers of rotational symmetry**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     */
    constructor(x: number, y: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({ x, y }: { x?: number; y?: number }): this;
  }

  const allSymbols: Map<string, Symbol>;
  export { allSymbols };

  export class LetterSymbol extends Symbol {
    readonly x: number;
    readonly y: number;
    readonly letter: string;
    /**
     * **Letters must be sorted into one type per area**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param letter - The letter of the symbol.
     */
    constructor(x: number, y: number, letter: string);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({
      x,
      y,
      letter,
    }: {
      x?: number;
      y?: number;
      letter?: string;
    }): this;
    withLetter(letter: string): this;
  }

  export class LotusSymbol extends DirectionLinkerSymbol {
    readonly x: number;
    readonly y: number;
    readonly orientation: Orientation;
    /**
     * **Areas containing this symbol must be symmetrical**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param orientation - The orientation of the symbol.
     */
    constructor(x: number, y: number, orientation: Orientation);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({
      x,
      y,
      orientation,
    }: {
      x?: number;
      y?: number;
      orientation?: Orientation;
    }): this;
  }

  export abstract class MultiEntrySymbol extends Symbol {
    /**
     * Determines if the description of two MultiEntrySymbols can be merged when displayed in the UI.
     * @param other - The other MultiEntrySymbol to compare to.
     * @returns Whether the two MultiEntrySymbols have the same description.
     */
    descriptionEquals(other: Instruction): boolean;
  }

  export class MyopiaSymbol extends Symbol {
    readonly directions: OrientationToggle;
    /**
     * **Viewpoint Numbers count visible cells in the four directions**
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param directions - The directions in which an arrow is pointing.
     */
    constructor(x: number, y: number, directions: OrientationToggle);
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get containsDiagonal(): boolean;
    validateSymbol(grid: GridData): State;
    copyWith({
      x,
      y,
      directions,
    }: {
      x?: number;
      y?: number;
      directions?: OrientationToggle;
    }): this;
    withDirections(directions: OrientationToggle): this;
  }

  /**
   * All symbols which contain a number should extend this class to be compatible with off by X rules.
   */
  export abstract class NumberSymbol extends Symbol {
    readonly x: number;
    readonly y: number;
    readonly number: number;
    constructor(x: number, y: number, number: number);
    abstract countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    validateSymbol(grid: GridData): State;
    withNumber(number: number): this;
  }

  export class QuestionMarkSign extends Sign {
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    copyWith({ x, y }: { x?: number; y?: number }): this;
  }

  /**
   * A sign is a symbol that is only used for illustrative purposes.
   * They should only appear in example grids of other instructions.
   */
  export abstract class Sign extends Symbol {
    validateSymbol(_grid: GridData): State;
  }

  export abstract class Symbol extends Instruction {
    readonly x: number;
    readonly y: number;
    constructor(x: number, y: number);
    abstract validateSymbol(grid: GridData): State;
    get placementStep(): number;
    withX(x: number): this;
    withY(y: number): this;
    withPosition(x: number, y: number): this;
  }

  export class ViewpointSymbol extends NumberSymbol {
    /**
     * **Viewpoint Numbers count visible cells in the four directions**
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The viewpoint number.
     */
    constructor(x: number, y: number, number: number);
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
    }: {
      x?: number;
      y?: number;
      number?: number;
    }): this;
    withNumber(number: number): this;
  }

  export class TileData {
    readonly exists: boolean;
    readonly fixed: boolean;
    readonly color: Color;
    constructor(exists: boolean, fixed: boolean, color: Color);
    /**
     * Create a gray tile.
     */
    static empty(): TileData;
    /**
     * Create a non-existent tile.
     */
    static doesNotExist(): TileData;
    copyWith({
      exists,
      fixed,
      color,
    }: {
      exists?: boolean;
      fixed?: boolean;
      color?: Color;
    }): this;
    withExists(exists: boolean): this;
    withFixed(fixed: boolean): this;
    withColor(color: Color): this;
    get isFixed(): boolean;
    equals(other: TileData): boolean;
    static create(char: string): TileData;
  }

  export class TileConnections {
    [y: number]: {
      [x: number]: boolean;
    };
    constructor();
    get topLeft(): boolean;
    set topLeft(value: boolean);
    get top(): boolean;
    set top(value: boolean);
    get topRight(): boolean;
    set topRight(value: boolean);
    get left(): boolean;
    set left(value: boolean);
    get center(): boolean;
    set center(value: boolean);
    get right(): boolean;
    set right(value: boolean);
    get bottomLeft(): boolean;
    set bottomLeft(value: boolean);
    get bottom(): boolean;
    set bottom(value: boolean);
    get bottomRight(): boolean;
    set bottomRight(value: boolean);
  }

  export function aggregateState(
    rules: RuleState[],
    symbols: Map<string, State[]>
  ): State;
  export function applyFinalOverrides(
    grid: GridData,
    solution: GridData | null,
    state: GridState
  ): GridState;
  export function validateGrid(
    grid: GridData,
    solution: GridData | null
  ): GridState;

  export { Symbol as _Symbol };
}
export {};
