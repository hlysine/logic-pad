/* prettier-ignore-start */

/* eslint-disable */

// @ts-nocheck

// noinspection JSUnusedGlobalSymbols
declare global {
  // Generated by dts-bundle-generator v9.5.1

  import { RegionConstrainer, SymbolGrid } from 'grilops';
  import { Optimize, Solver as Solver$1 } from 'z3-solver';
  import { z } from 'zod';

  interface Position$1 {
    readonly x: number;
    readonly y: number;
  }
  export interface Edge {
    readonly x1: number;
    readonly y1: number;
    readonly x2: number;
    readonly y2: number;
  }
  /**
   * Major rules are frequently referenced in grids to provide additional UI.
   */
  export declare enum MajorRule {
    MusicGrid = 'music',
    CompletePattern = 'complete_pattern',
    Underclued = 'underclued',
  }
  export declare enum State {
    Error = 'error',
    Satisfied = 'satisfied',
    Incomplete = 'incomplete',
  }
  export type RuleState =
    | {
        readonly state: State.Error;
        readonly positions: readonly Position$1[];
      }
    | {
        readonly state: State.Satisfied;
      }
    | {
        readonly state: State.Incomplete;
      };
  export interface GridState {
    final: State;
    rules: readonly RuleState[];
    symbols: ReadonlyMap<string, State[]>;
  }
  export declare enum Color {
    Dark = 'dark',
    Light = 'light',
    Gray = 'gray',
  }
  export declare enum Comparison {
    Equal = 'eq',
    AtLeast = 'ge',
    AtMost = 'le',
  }
  export declare const COMPARISONS: readonly Comparison[];
  export declare enum Direction {
    Up = 'up',
    Down = 'down',
    Left = 'left',
    Right = 'right',
  }
  export declare const DIRECTIONS: readonly Direction[];
  export type DirectionMap<T> = {
    [key in Direction]: T;
  };
  export type DirectionToggle = Readonly<DirectionMap<boolean>>;
  export declare function directionToggle(
    ...directions: readonly Direction[]
  ): {
    up: boolean;
    down: boolean;
    left: boolean;
    right: boolean;
  };
  export declare enum Orientation {
    Up = 'up',
    UpRight = 'up-right',
    Right = 'right',
    DownRight = 'down-right',
    Down = 'down',
    DownLeft = 'down-left',
    Left = 'left',
    UpLeft = 'up-left',
  }
  export declare const ORIENTATIONS: readonly Orientation[];
  export type OrientationMap<T> = {
    [key in Orientation]: T;
  };
  export type OrientationToggle = Readonly<OrientationMap<boolean>>;
  export declare function orientationToggle(
    ...orientations: readonly Orientation[]
  ): {
    up: boolean;
    'up-right': boolean;
    right: boolean;
    'down-right': boolean;
    down: boolean;
    'down-left': boolean;
    left: boolean;
    'up-left': boolean;
  };
  export declare enum Mode {
    Create = 'create',
    Solve = 'solve',
  }
  export declare class TileConnections {
    [y: number]: {
      [x: number]: boolean;
    };
    constructor();
    get topLeft(): boolean;
    set topLeft(value: boolean);
    get top(): boolean;
    set top(value: boolean);
    get topRight(): boolean;
    set topRight(value: boolean);
    get left(): boolean;
    set left(value: boolean);
    get center(): boolean;
    set center(value: boolean);
    get right(): boolean;
    set right(value: boolean);
    get bottomLeft(): boolean;
    set bottomLeft(value: boolean);
    get bottom(): boolean;
    set bottom(value: boolean);
    get bottomRight(): boolean;
    set bottomRight(value: boolean);
    equals(other: TileConnections): boolean;
  }
  export declare class GridConnections {
    readonly edges: readonly Edge[];
    constructor(edges?: readonly Edge[]);
    addEdge(edge: Edge): GridConnections;
    removeEdge(edge: Edge): GridConnections;
    isConnected(edge: Edge): boolean;
    getConnectionsAt({ x, y }: Position$1): readonly Edge[];
    getForTile({ x, y }: Position$1): TileConnections;
    getConnectedTiles({ x, y }: Position$1): readonly Position$1[];
    /**
     * Create new GridConnections from a string array.
     *
     * - Use `.` for cells that don't connect to anything.
     * - Use any other character for cells that connect to the same character.
     *
     * @param array - The string array to create the connections from.
     * @returns The created connections. You can apply this to a GridData object using GridData.withConnections.
     */
    static create(array: string[]): GridConnections;
    /**
     * Check if two GridConnections objects are equal.
     * @param other The other GridConnections object to compare to.
     * @returns Whether the two objects are equal.
     */
    equals(other: GridConnections): boolean;
    /**
     * Deduplicate an array of edges.
     * @param edges The array of edges to deduplicate.
     * @returns The deduplicated array of edges.
     */
    static deduplicateEdges(edges: readonly Edge[]): readonly Edge[];
    insertColumn(index: number): GridConnections;
    insertRow(index: number): GridConnections;
    removeColumn(index: number): GridConnections;
    removeRow(index: number): GridConnections;
  }
  /**
   * Offset the given position by a given step in the given direction.
   * @param position The position to offset.
   * @param direction The direction to offset in.
   * @param step The distance to offset by.
   * @returns The offset position.
   */
  export declare function move(
    position: Position$1,
    direction: Direction | Orientation,
    step?: number
  ): {
    x: number;
    y: number;
  };
  /**
   * Check if two edges are the same, regardless of direction.
   * @param a The first edge.
   * @param b The second edge.
   * @returns Whether the edges are the same.
   */
  export declare function isSameEdge(a: Edge, b: Edge): boolean;
  /**
   * Convert the given direction to a rotation in degrees.
   * @param direction The direction to convert.
   * @returns The rotation in degrees.
   */
  export declare function directionToRotation(
    direction: Direction
  ): 0 | 270 | 90 | 180;
  /**
   * Convert the given orientation to a rotation in degrees.
   * @param orientation The orientation to convert.
   * @returns The rotation in degrees.
   */
  export declare function orientationToRotation(
    orientation: Orientation
  ): 0 | 270 | 90 | 180 | 225 | 125 | 315 | 45;
  /**
   * Create a new 2D array with the given dimensions and values.
   * @param width The width of the array.
   * @param height The height of the array.
   * @param value A function that returns the value for each x,y coordinate.
   * @returns The 2D array.
   */
  export declare function array<T>(
    width: number,
    height: number,
    value: (x: number, y: number) => T
  ): T[][];
  /**
   * Resize the given array to the new size, cutting off or padding with the default value.
   * @param array The array to resize.
   * @param newSize The new size of the array.
   * @param defaultValue A function that returns the default value for each new element.
   * @returns The resized array.
   */
  export declare function resize<T>(
    array: T[],
    newSize: number,
    defaultValue: () => T
  ): T[];
  export declare function resize<T>(
    array: readonly T[],
    newSize: number,
    defaultValue: () => T
  ): readonly T[];
  /**
   * Check if all the given values are equal.
   * @param values The values to compare.
   * @returns Whether all the values are equal.
   */
  export declare function allEqual<T>(...values: T[]): boolean;
  /**
   * Return the first element of the array which has the minimum mapped value.
   *
   * @param values The array of values.
   * @param mapper The function to map each value to a number.
   * @returns The first element with the minimum mapped value.
   */
  export declare function minBy<T>(
    values: readonly T[],
    mapper: (element: T) => number
  ): T | undefined;
  /**
   * Return the first element of the array which has the maximum mapped value.
   *
   * @param values The array of values.
   * @param mapper The function to map each value to a number.
   * @returns The first element with the maximum mapped value.
   */
  export declare function maxBy<T>(
    values: readonly T[],
    mapper: (element: T) => number
  ): T | undefined;
  /**
   * Escape the given text by replacing the specified characters with HTML escape sequences.
   * @param text The text to escape.
   * @param escapeCharacters The characters to escape.
   * @returns The escaped text.
   */
  declare function escape$1(text: string, escapeCharacters?: string): string;
  /**
   * Unescape the given text by replacing HTML escape sequences with the corresponding characters.
   * @param text The text to unescape.
   * @param escapeCharacters The characters to unescape. This should match the characters escaped by the `escape` function.
   * @returns The unescaped text.
   */
  declare function unescape$1(text: string, escapeCharacters?: string): string;
  export declare class CachedAccess<T> {
    private readonly getter;
    private static readonly UNCACHED;
    private cache;
    private constructor();
    static of<T>(getter: () => T): CachedAccess<T>;
    get value(): T;
  }
  export declare abstract class Configurable {
    get configs(): readonly AnyConfig[] | null;
    abstract copyWith(props: Record<string, unknown>): this;
    /**
     * Check if this instruction is equal to another instruction by comparing their IDs and configs.
     *
     * @param other The other instruction to compare to.
     * @returns Whether the two instructions are equal.
     */
    equals(other: Configurable): boolean;
  }
  export declare abstract class Instruction extends Configurable {
    abstract get id(): string;
    abstract get explanation(): string;
    abstract createExampleGrid(): GridData;
    /**
     * Indicates that validation by logic is not available and the solution must be used for validation
     */
    get validateWithSolution(): boolean;
    get necessaryForCompletion(): boolean;
    get visibleWhenSolving(): boolean;
    /**
     * Check if this instruction is equal to another instruction by comparing their IDs and configs.
     *
     * @param other The other instruction to compare to.
     * @returns Whether the two instructions are equal.
     */
    equals(other: Instruction): boolean;
  }
  export interface SearchVariant {
    description: string;
    rule: Rule;
  }
  export declare abstract class Rule extends Instruction {
    abstract validateGrid(grid: GridData): RuleState;
    abstract get searchVariants(): SearchVariant[];
    searchVariant(): SearchVariant;
    /**
     * Whether only one instance of this rule is allowed in a grid.
     */
    get isSingleton(): boolean;
  }
  export interface GridResizeHandler {
    /**
     * Update itself when the grid is resized.
     */
    onGridResize(
      grid: GridData,
      mode: 'insert' | 'remove',
      direction: 'row' | 'column',
      index: number
    ): this | null;
  }
  export declare function handlesGridResize<T extends Instruction>(
    val: T
  ): val is T & GridResizeHandler;
  declare abstract class Symbol$1
    extends Instruction
    implements GridResizeHandler
  {
    readonly x: number;
    readonly y: number;
    constructor(x: number, y: number);
    abstract validateSymbol(grid: GridData): State;
    onGridResize(
      _grid: GridData,
      mode: 'insert' | 'remove',
      direction: 'row' | 'column',
      index: number
    ): this | null;
    /**
     * The step size for the x and y coordinates of the symbol.
     */
    get placementStep(): number;
    /**
     * The order in which symbols are displayed on the instruction list. Lower values are displayed first.
     */
    get sortOrder(): number;
    withX(x: number): this;
    withY(y: number): this;
    withPosition(x: number, y: number): this;
  }
  export declare class TileData {
    readonly exists: boolean;
    readonly fixed: boolean;
    readonly color: Color;
    constructor(exists: boolean, fixed: boolean, color: Color);
    /**
     * Create a gray tile.
     */
    static empty(): TileData;
    /**
     * Create a non-existent tile.
     */
    static doesNotExist(): TileData;
    copyWith({
      exists,
      fixed,
      color,
    }: {
      exists?: boolean;
      fixed?: boolean;
      color?: Color;
    }): this;
    withExists(exists: boolean): this;
    withFixed(fixed: boolean): this;
    withColor(color: Color): this;
    get isFixed(): boolean;
    equals(other: TileData): boolean;
    static create(char: string): TileData;
  }
  export interface GridChangeHandler {
    onGridChange(newGrid: GridData): this;
  }
  export declare function handlesGridChange<T extends Instruction>(
    val: T
  ): val is T & GridChangeHandler;
  export interface SetGridHandler {
    onSetGrid(
      oldGrid: GridData,
      newGrid: GridData,
      solution: GridData | null
    ): GridData;
  }
  export declare function handlesSetGrid<T extends Instruction>(
    val: T
  ): val is T & SetGridHandler;
  export declare class Row extends Configurable {
    /**
     * The note to play at this row, or null to keep the current note from the previous control line.
     * If this is null from the first control line, the note will be silent.
     */
    readonly note: string | null;
    /**
     * The velocity to play the note at, or null to keep the current velocity from the previous control line.
     * Ranges from 0 to 1
     */
    readonly velocity: number | null;
    private static readonly CONFIGS;
    constructor(
      /**
       * The note to play at this row, or null to keep the current note from the previous control line.
       * If this is null from the first control line, the note will be silent.
       */
      note: string | null,
      /**
       * The velocity to play the note at, or null to keep the current velocity from the previous control line.
       * Ranges from 0 to 1
       */
      velocity: number | null
    );
    get configs(): readonly AnyConfig[] | null;
    copyWith({
      note,
      velocity,
    }: {
      note?: string | null;
      velocity?: number | null;
    }): this;
  }
  export declare class ControlLine extends Configurable {
    readonly column: number;
    readonly bpm: number | null;
    readonly pedal: boolean | null;
    readonly checkpoint: boolean;
    readonly rows: readonly Row[];
    private static readonly CONFIGS;
    /**
     * Configure playback settings, taking effect at the given column (inclusive)
     * @param column The column at which the settings take effect
     * @param bpm The new beats per minute, or null to keep the current value from the previous control line
     * @param pedal Whether the pedal is pressed, or null to keep the current value from the previous control line
     * @param checkpoint Whether this control line is a checkpoint
     * @param rows The notes to play at each row. This list is automatically resized to match the height of the grid. You may pass in an empty list if none of the rows need to be changed.
     */
    constructor(
      column: number,
      bpm: number | null,
      pedal: boolean | null,
      checkpoint: boolean,
      rows: readonly Row[]
    );
    get configs(): readonly AnyConfig[] | null;
    copyWith({
      column,
      bpm,
      pedal,
      checkpoint,
      rows,
    }: {
      column?: number;
      bpm?: number | null;
      pedal?: boolean | null;
      checkpoint?: boolean;
      rows?: readonly Row[];
    }): this;
    withColumn(column: number): this;
    withBpm(bpm: number | null): this;
    withPedal(pedal: boolean | null): this;
    withCheckpoint(checkpoint: boolean): this;
    withRows(rows: readonly Row[]): this;
    equals(other: ControlLine): boolean;
    get isEmpty(): boolean;
  }
  export declare class MusicGridRule
    extends Rule
    implements GridChangeHandler, SetGridHandler, GridResizeHandler
  {
    readonly controlLines: readonly ControlLine[];
    readonly track: GridData | null;
    private static readonly EXAMPLE_GRID;
    private static readonly CONFIGS;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Music Grid: Listen to the solution**
     * @param controlLines Denote changes in the playback settings. At least one control line at column 0 should be present to enable playback.
     * @param track The grid to be played when "listen" is clicked. Set as null to play the solution.
     */
    constructor(controlLines: readonly ControlLine[], track: GridData | null);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    onSetGrid(
      _oldGrid: GridData,
      newGrid: GridData,
      _solution: GridData | null
    ): GridData;
    onGridChange(newGrid: GridData): this;
    onGridResize(
      _grid: GridData,
      mode: 'insert' | 'remove',
      direction: 'row' | 'column',
      index: number
    ): this | null;
    /**
     * Add or replace a control line.
     * @param controlLine The control line to set.
     * @returns A new rule with the control line set.
     */
    setControlLine(controlLine: ControlLine): this;
    withTrack(track: GridData | null): this;
    copyWith({
      controlLines,
      track,
    }: {
      controlLines?: readonly ControlLine[];
      track?: GridData | null;
    }): this;
    get validateWithSolution(): boolean;
    get isSingleton(): boolean;
    static mergeControlLines(...lines: ControlLine[]): ControlLine;
    static deduplicateControlLines(
      lines: readonly ControlLine[]
    ): ControlLine[];
  }
  export declare class CompletePatternRule extends Rule {
    private static readonly EXAMPLE_GRID;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Complete the pattern**
     *
     * This rule validates answers based on the provided solution.
     */
    constructor();
    get id(): string;
    get explanation(): string;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    copyWith(_: object): this;
    get validateWithSolution(): boolean;
    get isSingleton(): boolean;
  }
  export declare class UndercluedRule extends Rule {
    private static readonly EXAMPLE_GRID;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Underclued Grid: Mark only what is definitely true**
     *
     * This rule validates answers based on the provided solution.
     */
    constructor();
    get id(): string;
    get explanation(): string;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    copyWith(_: object): this;
    get validateWithSolution(): boolean;
    get isSingleton(): boolean;
  }
  export declare const NEIGHBOR_OFFSETS: Position$1[];
  export declare class GridData {
    readonly width: number;
    readonly height: number;
    readonly tiles: readonly (readonly TileData[])[];
    readonly connections: GridConnections;
    readonly symbols: ReadonlyMap<string, readonly Symbol$1[]>;
    readonly rules: readonly Rule[];
    readonly musicGrid: CachedAccess<MusicGridRule | undefined>;
    readonly completePattern: CachedAccess<CompletePatternRule | undefined>;
    readonly underclued: CachedAccess<UndercluedRule | undefined>;
    /**
     * Create a new grid with tiles, connections, symbols and rules.
     * @param width The width of the grid.
     * @param height The height of the grid.
     * @param tiles The tiles of the grid.
     * @param connections The connections of the grid, which determines which tiles are merged.
     * @param symbols The symbols in the grid.
     * @param rules The rules of the grid.
     */
    constructor(
      width: number,
      height: number,
      tiles?: readonly (readonly TileData[])[],
      connections?: GridConnections,
      symbols?: ReadonlyMap<string, readonly Symbol$1[]>,
      rules?: readonly Rule[]
    );
    /**
     * Copy the current grid while modifying the provided properties.
     * @param param0 The properties to modify.
     * @returns The new grid with the modified properties.
     */
    copyWith({
      width,
      height,
      tiles,
      connections,
      symbols,
      rules,
    }: {
      width?: number;
      height?: number;
      tiles?: readonly (readonly TileData[])[];
      connections?: GridConnections;
      symbols?: ReadonlyMap<string, readonly Symbol$1[]>;
      rules?: readonly Rule[];
    }): GridData;
    isPositionValid(x: number, y: number): boolean;
    /**
     * Safely get the tile at the given position.
     * @param x The x-coordinate of the tile.
     * @param y The y-coordinate of the tile.
     * @returns The tile at the given position, or a non-existent tile if the position is invalid.
     */
    getTile(x: number, y: number): TileData;
    /**
     * Safely set the tile at the given position.
     * If the position is invalid, the grid is returned unchanged.
     * If the tile is merged with other tiles, the colors of all connected tiles are changed.
     *
     * @param x The x-coordinate of the tile.
     * @param y The y-coordinate of the tile.
     * @param tile The new tile to set.
     * @returns The new grid with the tile set at the given position.
     */
    setTile(
      x: number,
      y: number,
      tile: TileData | ((tile: TileData) => TileData)
    ): GridData;
    /**
     * Replace or modify all tiles in the grid.
     *
     * @param tiles The new tile array or a function to mutate the existing tile array.
     * @returns The new grid with the new tiles.
     */
    withTiles(
      tiles:
        | readonly (readonly TileData[])[]
        | ((value: TileData[][]) => readonly (readonly TileData[])[])
    ): GridData;
    /**
     * Add or modify the connections in the grid.
     * @param connections The new connections to add or modify.
     * @returns The new grid with the new connections.
     */
    withConnections(
      connections:
        | GridConnections
        | ((value: GridConnections) => GridConnections)
    ): GridData;
    /**
     * Add or modify the symbols in the grid.
     * @param symbols The new symbols to add or modify.
     * @returns The new grid with the new symbols.
     */
    withSymbols(
      symbols:
        | readonly Symbol$1[]
        | ReadonlyMap<string, readonly Symbol$1[]>
        | ((
            value: Map<string, readonly Symbol$1[]>
          ) => ReadonlyMap<string, readonly Symbol$1[]>)
    ): GridData;
    /**
     * Add a new symbol to the grid.
     * @param symbol The symbol to add.
     * @returns The new grid with the new symbol.
     */
    addSymbol(symbol: Symbol$1): GridData;
    /**
     * Remove an instance of the symbol from the grid.
     * @param symbol The symbol to remove.
     * @returns The new grid with the symbol removed.
     */
    removeSymbol(symbol: Symbol$1): GridData;
    /**
     * Remove all symbols that satisfy the predicate.
     * @param predicate The predicate to test each symbol with.
     * @returns The new grid with the symbols removed.
     */
    removeSymbolIf(predicate: (symbol: Symbol$1) => boolean): GridData;
    /**
     * Find the first symbol that satisfies the predicate.
     * @param predicate The predicate to test each symbol with.
     * @returns The first symbol that satisfies the predicate, or undefined if no symbol is found.
     */
    findSymbol(predicate: (symbol: Symbol$1) => boolean): Symbol$1 | undefined;
    /**
     * Replace an existing symbol with a new symbol.
     * @param oldSymbol The symbol to replace.
     * @param newSymbol The new symbol to replace with.
     * @returns The new grid with the symbol replaced.
     */
    replaceSymbol(oldSymbol: Symbol$1, newSymbol: Symbol$1): GridData;
    /**
     * Add or modify the rules in the grid.
     * @param rules The new rules to add or modify.
     * @returns The new grid with the new rules.
     */
    withRules(
      rules: readonly Rule[] | ((value: readonly Rule[]) => readonly Rule[])
    ): GridData;
    /**
     * Add a new rule to the grid.
     * @param rule The rule to add.
     * @returns The new grid with the new rule.
     */
    addRule(rule: Rule): GridData;
    /**
     * Remove an instance of the rule from the grid.
     * @param rule The rule to remove.
     * @returns The new grid with the rule removed.
     */
    removeRule(rule: Rule): GridData;
    /**
     * Remove all rules that satisfy the predicate.
     * @param predicate The predicate to test each rule with.
     * @returns The new grid with the rules removed.
     */
    removeRuleIf(predicate: (rule: Rule) => boolean): GridData;
    /**
     * Find the first rule that satisfies the predicate.
     * @param predicate The predicate to test each rule with.
     * @returns The first rule that satisfies the predicate, or undefined if no rule is found.
     */
    findRule(predicate: (rule: Rule) => boolean): Rule | undefined;
    /**
     * Replace an existing rule with a new rule.
     * @param oldRule The rule to replace.
     * @param newRule The new rule to replace with.
     * @returns The new grid with the rule replaced.
     */
    replaceRule(oldRule: Rule, newRule: Rule): GridData;
    /**
     * Insert a new column at the given index, shifting all components of the grid accordingly. Newly inserted tiles are gray.
     * @param index The index to insert the column at.
     * @returns The new grid with the new column inserted.
     */
    insertColumn(index: number): GridData;
    /**
     * Insert a new row at the given index, shifting all components of the grid accordingly. Newly inserted tiles are gray.
     * @param index The index to insert the row at.
     * @returns The new grid with the new row inserted.
     */
    insertRow(index: number): GridData;
    /**
     * Remove a column at the given index, shifting all components of the grid accordingly.
     * @param index The index to remove the column at.
     * @returns The new grid with the column removed.
     */
    removeColumn(index: number): GridData;
    /**
     * Remove a row at the given index, shifting all components of the grid accordingly.
     * @param index The index to remove the row at.
     * @returns The new grid with the row removed.
     */
    removeRow(index: number): GridData;
    /**
     * Resize the grid to the new width and height, shifting all components of the grid accordingly. Newly inserted tiles are gray.
     * @param width The new width of the grid.
     * @param height The new height of the grid.
     * @returns The new grid with the new dimensions.
     */
    resize(width: number, height: number): this;
    /**
     * Create a new mutable TileData array from a string array.
     *
     * - Use `b` for dark cells, `w` for light cells, and `n` for gray cells.
     * - Capitalize the letter to make the tile fixed.
     * - Use `.` to represent empty space.
     *
     * @param array - The string array to create the tiles from.
     * @returns The created tile array.
     */
    static createTiles(array: string[]): TileData[][];
    /**
     * Create a new GridData object from a string array.
     *
     * - Use `b` for dark cells, `w` for light cells, and `n` for gray cells.
     * - Capitalize the letter to make the tile fixed.
     * - Use `.` to represent empty space.
     *
     * @param array - The string array to create the grid from.
     * @returns The created grid.
     */
    static create(array: string[]): GridData;
    /**
     * Find a tile in the grid that satisfies the predicate.
     *
     * @param predicate The predicate to test each tile with.
     * @returns The position of the first tile that satisfies the predicate, or undefined if no tile is found.
     */
    find(
      predicate: (tile: TileData, x: number, y: number) => boolean
    ): Position$1 | undefined;
    /**
     * Iterate over all tiles in the same region as the given position that satisfy the predicate.
     * The iteration stops when the callback returns a value that is not undefined.
     * Non-existent tiles are not included in the iteration.
     *
     * @param position The position to start the iteration from. This position is included in the iteration.
     * @param predicate The predicate to test each tile with. The callback is only called for tiles that satisfy this predicate.
     * @param callback The callback to call for each tile that satisfies the predicate. The iteration stops when this callback returns a value that is not undefined.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    iterateArea<T>(
      position: Position$1,
      predicate: (tile: TileData) => boolean,
      callback: (tile: TileData, x: number, y: number) => undefined | T
    ): T | undefined;
    /**
     * Iterate over all tiles in a straight line from the given position in the given direction that satisfy the predicate.
     * The iteration stops when the callback returns a value that is not undefined.
     * Non-existent tiles break the iteration.
     *
     * @param position The position to start the iteration from. This position is included in the iteration.
     * @param direction The direction to iterate in.
     * @param predicate The predicate to test each tile with. The callback is only called for tiles that satisfy this predicate.
     * @param callback The callback to call for each tile that satisfies the predicate. The iteration stops when this callback returns a value that is not undefined.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    iterateDirection<T>(
      position: Position$1,
      direction: Direction | Orientation,
      predicate: (tile: TileData) => boolean,
      callback: (tile: TileData, x: number, y: number) => T | undefined
    ): T | undefined;
    /**
     * Iterate over all tiles in a straight line from the given position in the given direction that satisfy the predicate.
     * The iteration stops when the callback returns a value that is not undefined.
     * Non-existent tiles are included in the iteration.
     *
     * @param position The position to start the iteration from. This position is included in the iteration.
     * @param direction The direction to iterate in.
     * @param predicate The predicate to test each tile with. The callback is only called for tiles that satisfy this predicate.
     * @param callback The callback to call for each tile that satisfies the predicate. The iteration stops when this callback returns a value that is not undefined.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    iterateDirectionAll<T>(
      position: Position$1,
      direction: Direction | Orientation,
      predicate: (tile: TileData) => boolean,
      callback: (tile: TileData, x: number, y: number) => T | undefined
    ): T | undefined;
    /**
     * Check if every tile in the grid is filled with a color other than gray.
     *
     * @returns True if every tile is filled with a color other than gray, false otherwise.
     */
    isComplete(): boolean;
    /**
     * Iterate over all tiles in the grid.
     * The iteration stops when the callback returns a value that is not undefined.
     *
     * @param callback The callback to call for each tile.
     * @returns The value returned by the callback that stopped the iteration, or undefined if the iteration completed.
     */
    forEach<T>(
      callback: (tile: TileData, x: number, y: number) => T | undefined
    ): T | undefined;
    /**
     * Flood fill a continuous region starting from the given position with the given color.
     *
     * @param position The position to start the flood fill from.
     * @param from The color of the tiles to fill.
     * @param to The color to fill the tiles with.
     * @param allowFixed Whether to fill fixed tiles.
     * @returns The new grid with the region filled with the new color.
     */
    floodFill(
      position: Position$1,
      from: Color,
      to: Color,
      allowFixed: boolean
    ): GridData;
    /**
     * Flood fill all tiles with the given color to a new color, even if they are not connected.
     *
     * @param from The color of the tiles to fill.
     * @param to The color to fill the tiles with.
     * @param allowFixed Whether to fill fixed tiles.
     * @returns The new grid with all tiles filled with the new color.
     */
    floodFillAll(from: Color, to: Color, allowFixed: boolean): GridData;
    /**
     * Check if the grid has any instructions that require a custom solution.
     * @returns True if the grid has any instructions that require a custom solution, false otherwise.
     */
    requireSolution(): boolean;
    /**
     * Reset all non-fixed tiles to gray.
     *
     * @returns The new grid with all non-fixed tiles reset to gray.
     */
    resetTiles(): this;
    /**
     * Copy the tiles in the given region to a new grid.
     * All connections and symbols within the selected region are copied.
     * All rules are included as well.
     *
     * @param origin The top-left corner of the region to copy.
     * @param width The width of the region to copy.
     * @param height The height of the region to copy.
     * @returns The new grid with the copied tiles.
     */
    copyTiles(origin: Position$1, width: number, height: number): GridData;
    /**
     * Paste the tiles from the given grid to the current grid at the given position.
     * All connections, symbols, and rules are merged.
     *
     * @param origin The top-left corner of the region to paste the tiles to.
     * @param grid The grid to paste the tiles from.
     * @returns The new grid with the pasted tiles.
     */
    pasteTiles(origin: Position$1, grid: GridData): GridData;
    /**
     * Paste the tiles from the given array to the current grid at the given position.
     *
     * @param origin The top-left corner of the region to paste the tiles to.
     * @param tile The array of tiles to paste.
     * @returns The new grid with the pasted tiles.
     */
    pasteTiles(
      origin: Position$1,
      tile: readonly (readonly TileData[])[]
    ): GridData;
    /**
     * Check if this grid is equal to another grid in terms of size and tile colors.
     * Rules, symbols, and connections are not compared.
     *
     * @param grid The grid to compare with.
     * @returns True if the grids are equal in size and tile colors, false otherwise.
     */
    colorEquals(grid: GridData): boolean;
    /**
     * Check if this grid conforms to the given solution, or an incomplete version of the solution.
     * Symbols and rules are not validated.
     *
     * @param solution The solution to compare with.
     * @returns True if the grid conforms to the solution, false otherwise.
     */
    solutionMatches(solution: GridData): boolean;
    /**
     * Check if this grid is equal to another grid in terms of size, tile colors, connections, symbols, and rules.
     *
     * @param other The grid to compare with.
     * @returns True if the grids are equal, false otherwise.
     */
    equals(other: GridData): boolean;
    /**
     * Get the count of tiles that satisfy the given conditions.
     * @param exists Whether the tile exists or not.
     * @param fixed Whether the tile is fixed or not. If undefined, the fixed state is ignored.
     * @param color The color of the tile. If undefined, all colors are included.
     * @returns The count of tiles that satisfy the given conditions.
     */
    getTileCount(
      exists: boolean,
      fixed?: boolean | undefined,
      color?: Color | undefined
    ): number;
    /**
     * Get the count of tiles that satisfy the given conditions for each color.
     * @param color The color of the tiles.
     * @returns The count of tiles that satisfy the given conditions for each color.
     */
    getColorCount(color: Color): {
      min: number;
      max: number;
    };
    /**
     * Deduplicate the rules in the given list.
     *
     * @param rules The list of rules to deduplicate.
     * @returns The deduplicated list of rules.
     */
    static deduplicateRules(rules: readonly Rule[]): Rule[];
    /**
     * Deduplicate the singleton rules in the given list.
     *
     * @param rules The list of rules to deduplicate.
     * @returns The deduplicated list of rules.
     */
    static deduplicateSingletonRules(rules: readonly Rule[]): Rule[];
    /**
     * Deduplicate the symbols in the given map.
     *
     * @param symbols The map of symbols to deduplicate.
     * @returns The deduplicated map of symbols.
     */
    static deduplicateSymbols(
      symbols: ReadonlyMap<string, readonly Symbol$1[]>
    ): Map<string, Symbol$1[]>;
  }
  export declare enum ConfigType {
    Boolean = 'boolean',
    NullableBoolean = 'nullableBoolean',
    Number = 'number',
    NullableNumber = 'nullableNumber',
    String = 'string',
    Color = 'color',
    Comparison = 'comparison',
    Direction = 'direction',
    DirectionToggle = 'directionToggle',
    Orientation = 'orientation',
    OrientationToggle = 'orientationToggle',
    Tile = 'tile',
    Grid = 'grid',
    NullableGrid = 'nullableGrid',
    Icon = 'icon',
    ControlLines = 'controlLines',
    NullableNote = 'nullableNote',
    SolvePath = 'solvePath',
    Edges = 'edges',
  }
  export interface Config<T> {
    readonly type: ConfigType;
    readonly field: string;
    readonly description: string;
    readonly default: T;
    readonly configurable: boolean;
  }
  export interface BooleanConfig extends Config<boolean> {
    readonly type: ConfigType.Boolean;
  }
  export interface NullableBooleanConfig extends Config<boolean | null> {
    readonly type: ConfigType.NullableBoolean;
  }
  export interface NumberConfig extends Config<number> {
    readonly type: ConfigType.Number;
    readonly min?: number;
    readonly max?: number;
    readonly step?: number;
  }
  export interface NullableNumberConfig extends Config<number | null> {
    readonly type: ConfigType.NullableNumber;
    readonly min?: number;
    readonly max?: number;
    readonly step?: number;
  }
  export interface StringConfig extends Config<string> {
    readonly type: ConfigType.String;
    readonly maxLength?: number;
    readonly placeholder?: string;
  }
  export interface ColorConfig extends Config<Color> {
    readonly type: ConfigType.Color;
    readonly allowGray: boolean;
  }
  export interface ComparisonConfig extends Config<Comparison> {
    readonly type: ConfigType.Comparison;
  }
  export interface DirectionConfig extends Config<Direction> {
    readonly type: ConfigType.Direction;
  }
  export interface DirectionToggleConfig extends Config<DirectionToggle> {
    readonly type: ConfigType.DirectionToggle;
  }
  export interface OrientationConfig extends Config<Orientation> {
    readonly type: ConfigType.Orientation;
  }
  export interface OrientationToggleConfig extends Config<OrientationToggle> {
    readonly type: ConfigType.OrientationToggle;
  }
  export interface TileConfig extends Config<GridData> {
    readonly type: ConfigType.Tile;
    readonly resizable: boolean;
  }
  export interface GridConfig extends Config<GridData> {
    readonly type: ConfigType.Grid;
  }
  export interface NullableGridConfig extends Config<GridData | null> {
    readonly type: ConfigType.NullableGrid;
    readonly nonNullDefault: GridData;
  }
  export interface IconConfig extends Config<string> {
    readonly type: ConfigType.Icon;
  }
  export interface ControlLinesConfig extends Config<ControlLine[]> {
    readonly type: ConfigType.ControlLines;
  }
  export interface NullableNoteConfig extends Config<string | null> {
    readonly type: ConfigType.NullableNote;
  }
  export interface SolvePathConfig extends Config<Position$1[]> {
    readonly type: ConfigType.SolvePath;
  }
  export interface EdgesConfig extends Config<Edge[]> {
    readonly type: ConfigType.Edges;
  }
  export type AnyConfig =
    | BooleanConfig
    | NullableBooleanConfig
    | NumberConfig
    | NullableNumberConfig
    | StringConfig
    | ColorConfig
    | ComparisonConfig
    | DirectionConfig
    | DirectionToggleConfig
    | OrientationConfig
    | OrientationToggleConfig
    | TileConfig
    | GridConfig
    | NullableGridConfig
    | IconConfig
    | ControlLinesConfig
    | NullableNoteConfig
    | SolvePathConfig
    | EdgesConfig;
  /**
   * Compare two config values for equality, using an appropriate method for the config type.
   *
   * @param type The type of the config.
   * @param a The first value to compare.
   * @param b The second value to compare.
   * @returns Whether the two values are equal.
   */
  export declare function configEquals<C extends AnyConfig>(
    type: C['type'],
    a: C['default'],
    b: C['default']
  ): boolean;
  export declare function isEventHandler<T>(
    val: unknown,
    event: string
  ): val is T;
  export interface FinalValidationHandler {
    /**
     * Edits the final grid state after all rules and symbols have been validated.
     *
     * @param grid The grid that is being validated.
     * @param solution The solution grid, or null if the solution is not available.
     * @param state The current state of the grid.
     */
    onFinalValidation(
      grid: GridData,
      solution: GridData | null,
      state: GridState
    ): GridState;
  }
  export declare function handlesFinalValidation<T extends Instruction>(
    val: T
  ): val is T & FinalValidationHandler;
  export interface SymbolDisplayHandler {
    /**
     * Controls whether a symbol should be visible in the grid.
     *
     * @param grid The grid that is being displayed.
     * @param symbol The symbol that is being displayed.
     * @param editing Whether the grid is being edited.
     * @returns True if the symbol should be displayed, false otherwise. The symbol will not be displayed if any handler returns false.
     */
    onSymbolDisplay(
      grid: GridData,
      symbol: Symbol$1,
      editing: boolean
    ): boolean;
  }
  export declare function handlesSymbolDisplay<T extends Instruction>(
    val: T
  ): val is T & SymbolDisplayHandler;
  export interface SymbolValidationHandler {
    /**
     * Overrides the validation of symbols.
     *
     * You can return a different validation result, or call the original validation logic with a modified grid.
     *
     * @param grid - The grid to validate.
     * @param _symbol - The symbol to validate.
     * @param validator - The original validation logic for the symbol.
     * @returns The state of the symbol after validation.
     */
    onSymbolValidation(
      grid: GridData,
      symbol: Symbol$1,
      validator: (grid: GridData) => State
    ): State | undefined;
  }
  export declare function handlesSymbolValidation<T extends Rule>(
    val: T
  ): val is T & SymbolValidationHandler;
  export type PuzzleMetadata = {
    /**
     * The title of the puzzle. (required)
     */
    title: string;
    /**
     * The author of the puzzle. (required)
     */
    author: string;
    /**
     * A description of the puzzle. (can be empty)
     */
    description: string;
    /**
     * A link to a place to discuss this puzzle. (can be empty)
     */
    link: string;
    /**
     * The difficulty of the puzzle, from 1 to 10. (required)
     *
     * 6-10 represent star difficulties.
     */
    difficulty: number;
  };
  export declare const MetadataSchema: z.ZodObject<
    {
      title: z.ZodString;
      author: z.ZodString;
      description: z.ZodString;
      link: z.ZodString;
      difficulty: z.ZodNumber;
    },
    'strict',
    z.ZodTypeAny,
    {
      description: string;
      title: string;
      author: string;
      link: string;
      difficulty: number;
    },
    {
      description: string;
      title: string;
      author: string;
      link: string;
      difficulty: number;
    }
  >;
  export declare const PuzzleSchema: z.ZodObject<
    {
      title: z.ZodString;
      author: z.ZodString;
      description: z.ZodString;
      link: z.ZodString;
      difficulty: z.ZodNumber;
      grid: z.ZodType<GridData, z.ZodTypeDef, GridData>;
      solution: z.ZodNullable<z.ZodType<GridData, z.ZodTypeDef, GridData>>;
    },
    'strict',
    z.ZodTypeAny,
    {
      description: string;
      grid: GridData;
      title: string;
      author: string;
      link: string;
      difficulty: number;
      solution: GridData | null;
    },
    {
      description: string;
      grid: GridData;
      title: string;
      author: string;
      link: string;
      difficulty: number;
      solution: GridData | null;
    }
  >;
  export type Puzzle = PuzzleMetadata & {
    /**
     * The grid of the puzzle. (required)
     *
     * You must fix all given cells in the grid. The rest of the cells will be cleared.
     */
    grid: GridData;
    /**
     * The solution to the puzzle. (optional)
     *
     * You should provide a solution if a rule requires it. Otherwise, the rule can never be satisfied.
     *
     * If there are no rules that require a solution, this field will be ignored.
     */
    solution: GridData | null;
  };
  export interface ShapeElement {
    x: number;
    y: number;
    color: Color;
  }
  export interface Shape {
    width: number;
    height: number;
    elements: ShapeElement[];
  }
  export declare function shapeEquals(a: Shape, b: Shape): boolean;
  export declare function tilesToShape(
    tiles: readonly (readonly TileData[])[]
  ): Shape;
  export declare function positionsToShape(
    positions: Position$1[],
    color: Color
  ): Shape;
  export declare function getShapeVariants(shape: Shape): Shape[];
  export declare function normalizeShape(shape: Shape): Shape;
  export declare class BanPatternRule extends Rule {
    private static readonly EXAMPLE_GRID;
    private static readonly CONFIGS;
    private static readonly SEARCH_VARIANTS;
    readonly pattern: GridData;
    readonly cache: Shape[];
    /**
     * **Don't make this pattern**
     *
     * @param pattern - GridData representing the banned pattern. Only non-gray tiles are considered.
     */
    constructor(pattern: GridData);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ pattern }: { pattern?: GridData }): this;
    withPattern(pattern: GridData): this;
  }
  export declare class CellCountPerZoneRule extends Rule {
    readonly color: Color;
    readonly edges: readonly Edge[];
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID_LIGHT;
    private static readonly EXAMPLE_GRID_DARK;
    private static readonly EXAMPLE_GRID_GRAY;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Every zone has the same number of &lt;color&gt; cells.**
     *
     * @param color - The color of the cells to count.
     * @param edges - The edges of the zones to count.
     */
    constructor(color: Color, edges: readonly Edge[]);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({
      color,
      edges,
    }: {
      color?: Color;
      edges?: readonly Edge[];
    }): this;
    withColor(color: Color): this;
    withEdges(
      edges: readonly Edge[] | ((edges: readonly Edge[]) => readonly Edge[])
    ): this;
  }
  export declare class CellCountRule extends Rule {
    readonly color: Color;
    readonly count: number;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID_LIGHT;
    private static readonly EXAMPLE_GRID_DARK;
    private static readonly SEARCH_VARIANTS;
    /**
     * **There are &lt;count&gt; &lt;color&gt; cells in total**
     *
     * @param color - The color of the cells to count.
     * @param count - The total number of cells of the given color.
     */
    constructor(color: Color, count: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color, count }: { color?: Color; count?: number }): this;
    withColor(color: Color): this;
    withCount(count: number): this;
  }
  export declare class ConnectAllRule extends Rule {
    readonly color: Color;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID_LIGHT;
    private static readonly EXAMPLE_GRID_DARK;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Connect all &lt;color&gt; cells**
     *
     * @param color - The color of the cells to connect.
     */
    constructor(color: Color);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color }: { color?: Color }): this;
    withColor(color: Color): this;
  }
  export declare class CustomRule extends Rule {
    readonly description: string;
    readonly grid: GridData;
    private static readonly EXAMPLE_GRID;
    static readonly configs: readonly AnyConfig[];
    private static readonly SEARCH_VARIANTS;
    /**
     * A custom rule with a description and thumbnail grid.
     *
     * This rule validates answers based on the provided solution.
     *
     * @param description - The description of the rule.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     */
    constructor(description: string, grid: GridData);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    copyWith({
      description,
      grid,
    }: {
      description?: string;
      grid?: GridData;
    }): this;
    get validateWithSolution(): boolean;
  }
  export declare class ForesightRule extends Rule {
    readonly count: number;
    readonly regenInterval: number;
    readonly startFull: boolean;
    readonly solvePath: Position$1[];
    private static readonly EXAMPLE_GRID;
    private static readonly CONFIGS;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Foresight: Show hints**
     */
    constructor(
      count: number,
      regenInterval: number,
      startFull: boolean,
      solvePath?: Position$1[]
    );
    get id(): string;
    get explanation(): string;
    get visibleWhenSolving(): boolean;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    get necessaryForCompletion(): boolean;
    get isSingleton(): boolean;
    copyWith({
      count,
      regenInterval,
      startFull,
      solvePath,
    }: {
      count?: number;
      regenInterval?: number;
      startFull?: boolean;
      solvePath?: Position$1[];
    }): this;
  }
  export declare const allRules: Map<string, Rule>;
  export declare class MysteryRule
    extends Rule
    implements FinalValidationHandler, GridChangeHandler, GridResizeHandler
  {
    readonly solution: GridData;
    readonly visible: boolean;
    private static readonly EXAMPLE_GRID;
    private static readonly CONFIGS;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Mystery: alternate solution**
     */
    constructor(solution: GridData, visible: boolean);
    get id(): string;
    get explanation(): string;
    get visibleWhenSolving(): boolean;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    get necessaryForCompletion(): boolean;
    onFinalValidation(
      grid: GridData,
      _solution: GridData | null,
      state: GridState
    ): GridState;
    onGridChange(newGrid: GridData): this;
    onGridResize(
      _grid: GridData,
      mode: 'insert' | 'remove',
      direction: 'row' | 'column',
      index: number
    ): this | null;
    copyWith({
      solution,
      visible,
    }: {
      solution?: GridData;
      visible?: boolean;
    }): this;
    withSolution(solution: GridData): this;
    withVisible(visible: boolean): this;
    static cleanSolution(solution: GridData, baseGrid?: GridData): GridData;
  }
  export declare class OffByXRule
    extends Rule
    implements SymbolValidationHandler
  {
    readonly number: number;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    private static readonly SEARCH_VARIANTS;
    /**
     * **All numbers are off by &lt;number&gt;**
     *
     * @param number - The number that all cells are off by.
     */
    constructor(number: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(_grid: GridData): RuleState;
    onSymbolValidation(
      grid: GridData,
      symbol: Symbol$1,
      _validator: (grid: GridData) => State
    ): State | undefined;
    get isSingleton(): boolean;
    copyWith({ number }: { number?: number }): this;
    withNumber(number: number): this;
  }
  export declare class PerfectionRule
    extends Rule
    implements SetGridHandler, FinalValidationHandler
  {
    private static readonly EXAMPLE_GRID;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Quest for Perfection: cell colors are final**
     */
    constructor();
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    get necessaryForCompletion(): boolean;
    get isSingleton(): boolean;
    validateGrid(grid: GridData): RuleState;
    /**
     * If the grid passes validation but is different from the solution, indicate the error in the final state.
     */
    onFinalValidation(
      grid: GridData,
      solution: GridData | null,
      state: GridState
    ): GridState;
    private fixTiles;
    /**
     * Force all tiles to be fixed.
     *
     * If the grid is already wrong, prevent the player from changing it further.
     */
    onSetGrid(
      oldGrid: GridData,
      newGrid: GridData,
      solution: GridData | null
    ): GridData;
    copyWith(_: object): this;
  }
  export declare class RegionAreaRule extends Rule {
    readonly color: Color;
    readonly size: number;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID_DARK;
    private static readonly EXAMPLE_GRID_LIGHT;
    private static readonly EXAMPLE_GRID_GRAY;
    private static readonly SEARCH_VARIANTS;
    /**
     * **All &lt;color&gt; regions have area &lt;size&gt;**
     *
     * @param color - The color of the regions.
     * @param size - The area of the regions.
     */
    constructor(color: Color, size: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color, size }: { color?: Color; size?: number }): this;
    withColor(color: Color): this;
    withSize(size: number): this;
  }
  export type ShapeRegions = {
    regions: {
      positions: Position$1[];
      shape: Shape;
      count: number;
    }[];
    complete: boolean;
  };
  export declare abstract class RegionShapeRule extends Rule {
    readonly color: Color;
    /**
     * @param color - The color of the regions to compare.
     */
    constructor(color: Color);
    protected getShapeRegions(grid: GridData): ShapeRegions;
    withColor(color: Color): this;
  }
  export declare class SameShapeRule extends RegionShapeRule {
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID_LIGHT;
    private static readonly EXAMPLE_GRID_DARK;
    private static readonly SEARCH_VARIANTS;
    /**
     * **All &lt;color&gt; areas have the same shape and size**
     *
     * @param color - The color of the regions to compare.
     */
    constructor(color: Color);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color }: { color?: Color }): this;
  }
  export declare class SymbolsPerRegionRule extends Rule {
    readonly color: Color;
    readonly count: number;
    readonly comparison: Comparison;
    private static readonly SYMBOL_POSITIONS;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRIDS;
    private static readonly SEARCH_VARIANTS;
    /**
     * **Exactly &lt;count&gt; symbols per &lt;color&gt; area**
     *
     * @param color - Color of the region affected by the rule
     * @param count - Number of symbols to have in each region
     * @param comparison - Comparison to use when checking the number of symbols
     */
    constructor(color: Color, count: number, comparison?: Comparison);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({
      count,
      color,
      comparison,
    }: {
      count?: number;
      color?: Color;
      comparison?: Comparison;
    }): this;
    withColor(color: Color): this;
    withCount(count: number): this;
    withComparison(comparison: Comparison): this;
    private static countAllSymbolsOfPosition;
  }
  export declare class UniqueShapeRule extends RegionShapeRule {
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID_LIGHT;
    private static readonly EXAMPLE_GRID_DARK;
    private static readonly SEARCH_VARIANTS;
    /**
     * **No two &lt;color&gt; areas have the same shape and size**
     *
     * @param color - The color of the regions to compare.
     */
    constructor(color: Color);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get searchVariants(): SearchVariant[];
    validateGrid(grid: GridData): RuleState;
    copyWith({ color }: { color?: Color }): this;
  }
  /**
   * The master serializer for puzzles.
   *
   * It uses the default serializer when stringifying puzzles, and select the correct deserializer when parsing puzzles.
   */
  export declare const Serializer: {
    stringifyRule(rule: Rule): string;
    parseRule(input: string): Rule;
    stringifySymbol(symbol: Symbol$1): string;
    parseSymbol(input: string): Symbol$1;
    stringifyGrid(grid: GridData): string;
    parseGrid(input: string): GridData;
    /**
     * Convert a puzzle to a string.
     * @param puzzle The puzzle to convert.
     * @returns The string representation of the puzzle.
     */
    stringifyPuzzle(puzzle: Puzzle): string;
    /**
     * Parse a puzzle from a string.
     * @param input The string to parse.
     * @returns The parsed puzzle.
     */
    parsePuzzle(input: string): Puzzle;
  };
  export declare abstract class CompressorBase {
    /**
     * The unique identifier for this compressor.
     */
    abstract get id(): string;
    /**
     * Compress the given input string into URL-safe compressed string.
     * @param input The input string to compress.
     */
    abstract compress(input: string): Promise<string>;
    /**
     * Decompress the given compressed string back into the original string.
     * @param input The compressed string to decompress.
     */
    abstract decompress(input: string): Promise<string>;
  }
  declare class MasterCompressor extends CompressorBase {
    get id(): string;
    compress(input: string): Promise<string>;
    decompress(input: string): Promise<string>;
  }
  export declare const Compressor: MasterCompressor;
  export declare abstract class StreamCompressor extends CompressorBase {
    protected abstract get algorithm(): CompressionFormat;
    compress(input: string): Promise<string>;
    decompress(input: string): Promise<string>;
  }
  export declare class DeflateCompressor extends StreamCompressor {
    get id(): string;
    protected get algorithm(): CompressionFormat;
    compress(input: string): Promise<string>;
    decompress(input: string): Promise<string>;
  }
  export declare class GzipCompressor extends StreamCompressor {
    get id(): string;
    protected get algorithm(): CompressionFormat;
  }
  export declare abstract class SerializerBase {
    abstract get version(): number;
    abstract stringifyTile(tile: TileData): string;
    abstract parseTile(str: string): TileData;
    abstract stringifyRule(rule: Rule): string;
    abstract stringifySymbol(symbol: Symbol$1): string;
    abstract parseRule(str: string): Rule;
    abstract parseSymbol(str: string): Symbol$1;
    abstract stringifyConnections(connections: GridConnections): string;
    abstract parseConnections(input: string): GridConnections;
    abstract stringifyTiles(tiles: readonly (readonly TileData[])[]): string;
    abstract parseTiles(input: string): TileData[][];
    abstract stringifyRules(rules: readonly Rule[]): string;
    abstract parseRules(input: string): Rule[];
    abstract stringifySymbols(
      symbols: ReadonlyMap<string, readonly Symbol$1[]>
    ): string;
    abstract parseSymbols(input: string): Map<string, Symbol$1[]>;
    abstract stringifyGrid(grid: GridData): string;
    abstract parseGrid(input: string): GridData;
    abstract stringifyPuzzle(puzzle: Puzzle): string;
    abstract parsePuzzle(input: string): Puzzle;
  }
  export declare class SerializerV0 extends SerializerBase {
    readonly version = 0;
    stringifyTile(tile: TileData): string;
    parseTile(str: string): TileData;
    stringifyControlLine(line: ControlLine): string;
    parseControlLine(str: string): ControlLine;
    stringifyConfig(instruction: Instruction, config: AnyConfig): string;
    parseConfig(
      configs: readonly AnyConfig[],
      entry: string
    ): [string, unknown];
    stringifyInstruction(instruction: Instruction): string;
    stringifyRule(rule: Rule): string;
    stringifySymbol(symbol: Symbol$1): string;
    parseRule(str: string): Rule;
    parseSymbol(str: string): Symbol$1;
    stringifyConnections(connections: GridConnections): string;
    parseConnections(input: string): GridConnections;
    stringifyTiles(tiles: readonly (readonly TileData[])[]): string;
    parseTiles(input: string): TileData[][];
    stringifyRules(rules: readonly Rule[]): string;
    parseRules(input: string): Rule[];
    stringifySymbols(symbols: ReadonlyMap<string, readonly Symbol$1[]>): string;
    parseSymbols(input: string): Map<string, Symbol$1[]>;
    stringifyGrid(grid: GridData): string;
    parseGrid(input: string): GridData;
    stringifyPuzzle(puzzle: Puzzle): string;
    parsePuzzle(input: string): Puzzle;
  }
  /**
   * Base class that all solvers must extend.
   */
  export declare abstract class Solver {
    /**
     * The unique identifier of the solver.
     *
     * This is also displayed to the user when selecting a solver.
     */
    abstract get id(): string;
    /**
     * A short paragraph describing when the user should use this solver.
     */
    abstract get description(): string;
    /**
     * Solve the given grid. The implementation should delegate long-running tasks to a worker thread and yield solutions
     * asynchronously.
     *
     * The solver must yield at least once, otherwise the UI will not update.
     *
     * If the solver finds no solution other than those already yielded, it should yield `null`. Yielding `null` on the
     * first iteration indicates that the grid is unsolvable. Yielding `null` on the second iteration indicates that the
     * solution is unique.
     *
     * In the current UI implementation, the solver will be terminated after yielding `null`, or after 2 iterations if
     * `null` is never yielded. The solver should perform any necessary cleanup in the `finally` block of the generator.
     *
     * @param grid The grid to solve. The provided grid is guaranteed to be supported by the solver. Some tiles in the
     * grid may already be filled by the user. It is up to the solver to decide whether to respect these tiles or not.
     */
    abstract solve(grid: GridData): AsyncGenerator<GridData | null>;
    /**
     * Check if the solver supports the current browser environment. This method is called once when the user first clicks
     * the "Solve" button, and the result is cached for the duration of the editor session.
     *
     * The `solve` method will not be called if this method returns `false`, and a message will be displayed to the user
     * indicating that the solver is not supported.
     *
     * @returns A promise that resolves to `true` if the environment is supported, or `false` otherwise.
     */
    isEnvironmentSupported(): Promise<boolean>;
    /**
     * Check if the solver supports the given instruction. This is used to render a small indication in the UI for each
     * instruction in the editor.
     *
     * @param instructionId The unique identifier of the instruction.
     */
    isInstructionSupported(instructionId: string): boolean;
    /**
     * Check if the solver supports the given grid. This methid is frequently called when the user changes the grid, and
     * the result is used to enable or disable the "Solve" button.
     *
     * The `solve` method will not be called if this method returns `false`, and a message will be displayed to the user
     * indicating that the grid is not supported by this solver.
     *
     * @param grid The grid to check.
     * @returns `true` if the grid is supported, or `false` otherwise.
     */
    isGridSupported(grid: GridData): boolean;
  }
  export declare const allSolvers: Map<string, Solver>;
  export declare class BacktrackSolver extends Solver {
    private static readonly supportedInstrs;
    readonly id = 'backtrack';
    readonly description =
      'Solves puzzles using backtracking with optimizations (blazingly fast). Support most rules and symbols (including underclued).';
    solve(grid: GridData): AsyncGenerator<GridData | null>;
    isInstructionSupported(instructionId: string): boolean;
  }
  export declare enum BTTile {
    Empty = 0,
    Dark = 1,
    Light = 2,
    NonExist = 3,
  }
  export type BTColor = BTTile.Dark | BTTile.Light;
  export declare class BTGridData {
    readonly tiles: BTTile[][];
    readonly connections: Position$1[][][];
    readonly modules: BTModule[];
    readonly width: number;
    readonly height: number;
    constructor(
      tiles: BTTile[][],
      connections: Position$1[][][],
      modules: BTModule[],
      width: number,
      height: number
    );
    getTile(x: number, y: number): BTTile;
    setTileWithConnection(x: number, y: number, tile: BTTile): void;
    isInBound(x: number, y: number): boolean;
    getEdges(pos: Position$1): Position$1[];
    clone(): BTGridData;
  }
  export declare class IntArray2D {
    private readonly array;
    readonly width: number;
    readonly height: number;
    private constructor();
    static create(width: number, height: number): IntArray2D;
    set(x: number, y: number, value: number): void;
    get(x: number, y: number): number;
    clone(): IntArray2D;
  }
  export interface CheckResult {
    tilesNeedCheck: IntArray2D | null;
    ratings: Rating[] | null;
  }
  export interface Rating {
    pos: Position$1;
    score: number;
  }
  export declare abstract class BTModule {
    abstract checkGlobal(grid: BTGridData): CheckResult | false;
    checkLocal(grid: BTGridData, _: Position$1[]): CheckResult | boolean;
  }
  export declare function getOppositeColor(color: BTColor): BTColor;
  export declare function colorToBTTile(color: Color): BTTile;
  export declare function createOneTileResult(
    grid: BTGridData,
    pos: Position$1,
    score?: number | undefined
  ): CheckResult;
  export declare class BanPatternBTModule extends BTModule {
    instr: BanPatternRule;
    constructor(instr: BanPatternRule);
    checkGlobal(grid: BTGridData): CheckResult | false;
    checkLocal(grid: BTGridData, positions: Position$1[]): CheckResult | false;
  }
  export declare class CellCountBTModule extends BTModule {
    instr: CellCountRule;
    constructor(instr: CellCountRule);
    checkGlobal(grid: BTGridData): CheckResult | false;
  }
  export declare class ConnectAllBTModule extends BTModule {
    instr: ConnectAllRule;
    constructor(instr: ConnectAllRule);
    checkGlobal(grid: BTGridData): CheckResult | false;
  }
  export declare class RegionAreaBTModule extends BTModule {
    instr: RegionAreaRule;
    constructor(instr: RegionAreaRule);
    checkGlobal(grid: BTGridData): CheckResult | false;
    private visitArea;
  }
  export declare abstract class RegionShapeBTModule extends BTModule {
    instr: RegionShapeRule;
    constructor(instr: RegionShapeRule);
    protected getShapeRegions(grid: BTGridData): ShapeRegions['regions'];
    private visitArea;
  }
  export declare class SameShapeBTModule extends RegionShapeBTModule {
    instr: SameShapeRule;
    constructor(instr: SameShapeRule);
    checkGlobal(grid: BTGridData): CheckResult | false;
  }
  export declare class SymbolsPerRegionBTModule extends BTModule {
    instr: SymbolsPerRegionRule;
    private symbolCount;
    constructor(
      instr: SymbolsPerRegionRule,
      width: number,
      height: number,
      allSymbols: Symbol$1[]
    );
    checkGlobal(grid: BTGridData): CheckResult | false;
    private visitArea;
  }
  export declare class UniqueShapeBTModule extends RegionShapeBTModule {
    instr: UniqueShapeRule;
    constructor(instr: UniqueShapeRule);
    checkGlobal(grid: BTGridData): CheckResult | false;
  }
  /**
   * All symbols which contain a number should extend this class to be compatible with off by X rules.
   */
  export declare abstract class NumberSymbol extends Symbol$1 {
    readonly x: number;
    readonly y: number;
    readonly number: number;
    constructor(x: number, y: number, number: number);
    abstract countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    validateSymbol(grid: GridData): State;
    withNumber(number: number): this;
  }
  export declare class AreaNumberSymbol extends NumberSymbol {
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    /**
     * **Area Numbers must equal region sizes**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The area number.
     */
    constructor(x: number, y: number, number: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
    }: {
      x?: number;
      y?: number;
      number?: number;
    }): this;
    withNumber(number: number): this;
  }
  export declare class AreaNumberBTModule extends BTModule {
    instr: AreaNumberSymbol;
    constructor(instr: AreaNumberSymbol);
    checkGlobal(grid: BTGridData): CheckResult | false;
    checkLocal(
      grid: BTGridData,
      positions: Position$1[]
    ): CheckResult | boolean;
  }
  export declare class DartSymbol extends NumberSymbol {
    readonly orientation: Orientation;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    /**
     * **Darts count opposite color cells in that direction**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The number of cells seen by the symbol.
     * @param orientation - The orientation of the symbol.
     */
    constructor(x: number, y: number, number: number, orientation: Orientation);
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
      orientation,
    }: {
      x?: number;
      y?: number;
      number?: number;
      orientation?: Orientation;
    }): this;
    withNumber(number: number): this;
  }
  export declare class DartBTModule extends BTModule {
    instr: DartSymbol;
    constructor(instr: DartSymbol);
    checkGlobal(grid: BTGridData): CheckResult | false;
    private buildCheckAndRating;
  }
  export type DirectionLinkerMap = {
    [key in Direction]: Direction;
  };
  export declare class DirectionLinkerSymbol extends Symbol$1 {
    readonly x: number;
    readonly y: number;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    private static readonly directionDeltas;
    private linkedDirections;
    /**
     * **Darts count opposite color cells in that direction**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     */
    constructor(x: number, y: number);
    changeDirections(linkedDirections: DirectionLinkerMap): this;
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    private deltaCoordinate;
    validateSymbol(grid: GridData): State;
    copyWith({ x, y }: { x?: number; y?: number }): this;
    private getInitialCheckedCouples;
  }
  export declare abstract class DirectionLinkerBTModule extends BTModule {
    instr: DirectionLinkerSymbol;
    constructor(instr: DirectionLinkerSymbol);
    private initialPositions;
    private getInitialPositions;
    checkGlobal(grid: BTGridData): CheckResult | false;
    protected abstract movePos(
      grid: BTGridData,
      x: number,
      y: number
    ): Position$1 | null;
  }
  export declare class GalaxySymbol extends DirectionLinkerSymbol {
    readonly x: number;
    readonly y: number;
    private static readonly linkedDirections;
    /**
     * **Galaxies are centers of rotational symmetry**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     */
    constructor(x: number, y: number);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({ x, y }: { x?: number; y?: number }): this;
  }
  export declare class GalaxyBTModule extends DirectionLinkerBTModule {
    instr: GalaxySymbol;
    constructor(instr: GalaxySymbol);
    protected movePos(
      grid: BTGridData,
      x: number,
      y: number
    ): Position$1 | null;
  }
  export declare class LetterSymbol extends Symbol$1 {
    readonly x: number;
    readonly y: number;
    readonly letter: string;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    /**
     * **Letters must be sorted into one type per area**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param letter - The letter of the symbol.
     */
    constructor(x: number, y: number, letter: string);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({
      x,
      y,
      letter,
    }: {
      x?: number;
      y?: number;
      letter?: string;
    }): this;
    withLetter(letter: string): this;
  }
  export declare class LetterBTModule extends BTModule {
    private letters;
    private letterGrid;
    constructor(instrs: LetterSymbol[], width: number, height: number);
    checkGlobal(grid: BTGridData): CheckResult | false;
    private visitArea;
  }
  export declare class LotusSymbol extends DirectionLinkerSymbol {
    readonly x: number;
    readonly y: number;
    readonly orientation: Orientation;
    private static readonly linkedDirectionsFromOrientation;
    /**
     * **Areas containing this symbol must be symmetrical**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param orientation - The orientation of the symbol.
     */
    constructor(x: number, y: number, orientation: Orientation);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({
      x,
      y,
      orientation,
    }: {
      x?: number;
      y?: number;
      orientation?: Orientation;
    }): this;
  }
  export declare class LotusBTModule extends DirectionLinkerBTModule {
    instr: LotusSymbol;
    constructor(instr: LotusSymbol);
    protected movePos(
      grid: BTGridData,
      x: number,
      y: number
    ): Position$1 | null;
    private getTileSafe;
    checkGlobal(grid: BTGridData): false | CheckResult;
  }
  export declare class MinesweeperSymbol extends NumberSymbol {
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    /**
     * **Minesweeper numbers count opposite cells in 8 adjacent spaces**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The number of cells seen by the symbol.
     */
    constructor(x: number, y: number, number: number);
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
    }: {
      x?: number;
      y?: number;
      number?: number;
    }): this;
    withNumber(number: number): this;
  }
  export declare class MinesweeperBTModule extends BTModule {
    instr: MinesweeperSymbol;
    private cachedCheckResult?;
    constructor(instr: MinesweeperSymbol);
    checkGlobal(grid: BTGridData): CheckResult | false;
    private buildCheckAndRating;
  }
  export declare abstract class MultiEntrySymbol extends Symbol$1 {
    /**
     * Determines if the description of two MultiEntrySymbols can be merged when displayed in the UI.
     * @param other - The other MultiEntrySymbol to compare to.
     * @returns Whether the two MultiEntrySymbols have the same description.
     */
    descriptionEquals(other: Instruction): boolean;
  }
  export declare class MyopiaSymbol extends MultiEntrySymbol {
    readonly diagonals: boolean;
    readonly directions: OrientationToggle;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    private static readonly EXAMPLE_DIAGONAL_GRID;
    /**
     * **Viewpoint Numbers count visible cells in the four directions**
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param diagonals - Whether the symbol should consider diagonal directions.
     * @param directions - The directions in which an arrow is pointing.
     */
    constructor(
      x: number,
      y: number,
      diagonals: boolean,
      directions: OrientationToggle
    );
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    validateSymbol(grid: GridData): State;
    copyWith({
      x,
      y,
      diagonals,
      directions,
    }: {
      x?: number;
      y?: number;
      diagonals?: boolean;
      directions?: OrientationToggle;
    }): this;
    withDirections(directions: OrientationToggle): this;
    withDiagonals(diagonals: boolean): this;
  }
  export declare class MyopiaBTModule extends BTModule {
    instr: MyopiaSymbol;
    constructor(instr: MyopiaSymbol);
    checkGlobal(grid: BTGridData): CheckResult | false;
  }
  export declare class ViewpointSymbol extends NumberSymbol {
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    /**
     * **Viewpoint Numbers count visible cells in the four directions**
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param number - The viewpoint number.
     */
    constructor(x: number, y: number, number: number);
    get id(): string;
    get placementStep(): number;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    private countForColor;
    countTiles(grid: GridData): {
      completed: number;
      possible: number;
    };
    copyWith({
      x,
      y,
      number,
    }: {
      x?: number;
      y?: number;
      number?: number;
    }): this;
    withNumber(number: number): this;
  }
  export declare class ViewpointBTModule extends BTModule {
    instr: ViewpointSymbol;
    constructor(instr: ViewpointSymbol);
    checkGlobal(grid: BTGridData): CheckResult | false;
  }
  export declare class UndercluedSolver extends Solver {
    readonly id = 'underclued';
    readonly description =
      'Solves every puzzle as if it were underclued. Supports all rules and symbols and is decently fast for small puzzles. Very slow for large puzzles.';
    solve(grid: GridData): AsyncGenerator<GridData | null>;
    isInstructionSupported(instructionId: string): boolean;
  }
  export declare class Z3SolverContext<
    Name extends string,
    const Core extends Solver$1<Name> | Optimize<Name> =
      | Solver$1<Name>
      | Optimize<Name>,
  > {
    readonly grid: SymbolGrid<Name, Core>;
    private _regionConstrainer;
    constructor(grid: SymbolGrid<Name, Core>);
    get solver(): Core;
    get lattice(): import('grilops').Lattice;
    get symbolSet(): import('grilops').SymbolSet;
    get ctx(): import('z3-solver').Context<Name>;
    get z3(): {
      mk_context: (
        c: import('z3-solver').Z3_config
      ) => import('z3-solver').Z3_context;
      mk_context_rc: (
        c: import('z3-solver').Z3_config
      ) => import('z3-solver').Z3_context;
      global_param_set: (param_id: string, param_value: string) => void;
      global_param_reset_all: () => void;
      global_param_get: (param_id: string) => string | null;
      mk_config: () => import('z3-solver').Z3_config;
      del_config: (c: import('z3-solver').Z3_config) => void;
      set_param_value: (
        c: import('z3-solver').Z3_config,
        param_id: string,
        param_value: string
      ) => void;
      del_context: (c: import('z3-solver').Z3_context) => void;
      inc_ref: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => void;
      dec_ref: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => void;
      update_param_value: (
        c: import('z3-solver').Z3_context,
        param_id: string,
        param_value: string
      ) => void;
      get_global_param_descrs: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_param_descrs;
      interrupt: (c: import('z3-solver').Z3_context) => void;
      enable_concurrent_dec_ref: (c: import('z3-solver').Z3_context) => void;
      mk_params: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_params;
      params_inc_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params
      ) => void;
      params_dec_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params
      ) => void;
      params_set_bool: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: boolean
      ) => void;
      params_set_uint: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: number
      ) => void;
      params_set_double: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: number
      ) => void;
      params_set_symbol: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        k: import('z3-solver').Z3_symbol,
        v: import('z3-solver').Z3_symbol
      ) => void;
      params_to_string: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params
      ) => string;
      params_validate: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_params,
        d: import('z3-solver').Z3_param_descrs
      ) => void;
      param_descrs_inc_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => void;
      param_descrs_dec_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => void;
      param_descrs_get_kind: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs,
        n: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_param_kind;
      param_descrs_size: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => number;
      param_descrs_get_name: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs,
        i: number
      ) => import('z3-solver').Z3_symbol;
      param_descrs_get_documentation: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs,
        s: import('z3-solver').Z3_symbol
      ) => string;
      param_descrs_to_string: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_param_descrs
      ) => string;
      mk_int_symbol: (
        c: import('z3-solver').Z3_context,
        i: number
      ) => import('z3-solver').Z3_symbol;
      mk_string_symbol: (
        c: import('z3-solver').Z3_context,
        s: string
      ) => import('z3-solver').Z3_symbol;
      mk_uninterpreted_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_sort;
      mk_type_variable: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_sort;
      mk_bool_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_int_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_real_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_bv_sort: (
        c: import('z3-solver').Z3_context,
        sz: number
      ) => import('z3-solver').Z3_sort;
      mk_finite_domain_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        size: bigint
      ) => import('z3-solver').Z3_sort;
      mk_array_sort: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort,
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_array_sort_n: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_tuple_sort: (
        c: import('z3-solver').Z3_context,
        mk_tuple_name: import('z3-solver').Z3_symbol,
        field_names: import('z3-solver').Z3_symbol[],
        field_sorts: import('z3-solver').Z3_sort[]
      ) => {
        rv: import('z3-solver').Z3_sort;
        mk_tuple_decl: import('z3-solver').Z3_func_decl;
        proj_decl: import('z3-solver').Z3_func_decl[];
      };
      mk_enumeration_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        enum_names: import('z3-solver').Z3_symbol[]
      ) => {
        rv: import('z3-solver').Z3_sort;
        enum_consts: import('z3-solver').Z3_func_decl[];
        enum_testers: import('z3-solver').Z3_func_decl[];
      };
      mk_list_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        elem_sort: import('z3-solver').Z3_sort
      ) => {
        rv: import('z3-solver').Z3_sort;
        nil_decl: import('z3-solver').Z3_func_decl;
        is_nil_decl: import('z3-solver').Z3_func_decl;
        cons_decl: import('z3-solver').Z3_func_decl;
        is_cons_decl: import('z3-solver').Z3_func_decl;
        head_decl: import('z3-solver').Z3_func_decl;
        tail_decl: import('z3-solver').Z3_func_decl;
      };
      mk_constructor: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        recognizer: import('z3-solver').Z3_symbol,
        field_names: import('z3-solver').Z3_symbol[],
        sorts: (import('z3-solver').Z3_sort | null)[],
        sort_refs: number[]
      ) => import('z3-solver').Z3_constructor;
      constructor_num_fields: (
        c: import('z3-solver').Z3_context,
        constr: import('z3-solver').Z3_constructor
      ) => number;
      del_constructor: (
        c: import('z3-solver').Z3_context,
        constr: import('z3-solver').Z3_constructor
      ) => void;
      mk_datatype: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        constructors: import('z3-solver').Z3_constructor[]
      ) => import('z3-solver').Z3_sort;
      mk_datatype_sort: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_sort;
      mk_constructor_list: (
        c: import('z3-solver').Z3_context,
        constructors: import('z3-solver').Z3_constructor[]
      ) => import('z3-solver').Z3_constructor_list;
      del_constructor_list: (
        c: import('z3-solver').Z3_context,
        clist: import('z3-solver').Z3_constructor_list
      ) => void;
      mk_datatypes: (
        c: import('z3-solver').Z3_context,
        sort_names: import('z3-solver').Z3_symbol[],
        constructor_lists: import('z3-solver').Z3_constructor_list[]
      ) => import('z3-solver').Z3_sort[];
      query_constructor: (
        c: import('z3-solver').Z3_context,
        constr: import('z3-solver').Z3_constructor,
        num_fields: number
      ) => {
        constructor: import('z3-solver').Z3_func_decl;
        tester: import('z3-solver').Z3_func_decl;
        accessors: import('z3-solver').Z3_func_decl[];
      };
      mk_func_decl: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      mk_app: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_const: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fresh_func_decl: (
        c: import('z3-solver').Z3_context,
        prefix: string,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      mk_fresh_const: (
        c: import('z3-solver').Z3_context,
        prefix: string,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_rec_func_decl: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      add_rec_def: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl,
        args: import('z3-solver').Z3_ast[],
        body: import('z3-solver').Z3_ast
      ) => void;
      mk_true: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_false: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_eq: (
        c: import('z3-solver').Z3_context,
        l: import('z3-solver').Z3_ast,
        r: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_distinct: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_not: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ite: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        t3: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_iff: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_implies: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_xor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_and: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_or: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_add: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_mul: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_sub: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_unary_minus: (
        c: import('z3-solver').Z3_context,
        arg: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_div: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_mod: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_rem: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_power: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_lt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_le: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_gt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ge: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_divides: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_int2real: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_real2int: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_is_int: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvnot: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvredand: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvredor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvand: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvxor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvnand: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvnor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvxnor: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvneg: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvadd: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsub: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvmul: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvudiv: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsdiv: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvurem: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsrem: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsmod: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvult: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvslt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvule: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsle: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvuge: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsge: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvugt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsgt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_concat: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_extract: (
        c: import('z3-solver').Z3_context,
        high: number,
        low: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_sign_ext: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_zero_ext: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_repeat: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bit2bool: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvshl: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvlshr: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvashr: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_rotate_left: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_rotate_right: (
        c: import('z3-solver').Z3_context,
        i: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ext_rotate_left: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ext_rotate_right: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_int2bv: (
        c: import('z3-solver').Z3_context,
        n: number,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bv2int: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvadd_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvadd_no_underflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsub_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvsub_no_underflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvsdiv_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvneg_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_bvmul_no_overflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        is_signed: boolean
      ) => import('z3-solver').Z3_ast;
      mk_bvmul_no_underflow: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_select: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_select_n: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        idxs: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_store: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: import('z3-solver').Z3_ast,
        v: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_store_n: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        idxs: import('z3-solver').Z3_ast[],
        v: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_const_array: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort,
        v: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_map: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_array_default: (
        c: import('z3-solver').Z3_context,
        array: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_as_array: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      mk_set_has_size: (
        c: import('z3-solver').Z3_context,
        set: import('z3-solver').Z3_ast,
        k: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_sort: (
        c: import('z3-solver').Z3_context,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_empty_set: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_full_set: (
        c: import('z3-solver').Z3_context,
        domain: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_set_add: (
        c: import('z3-solver').Z3_context,
        set: import('z3-solver').Z3_ast,
        elem: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_del: (
        c: import('z3-solver').Z3_context,
        set: import('z3-solver').Z3_ast,
        elem: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_union: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_set_intersect: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_set_difference: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_complement: (
        c: import('z3-solver').Z3_context,
        arg: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_member: (
        c: import('z3-solver').Z3_context,
        elem: import('z3-solver').Z3_ast,
        set: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_set_subset: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_array_ext: (
        c: import('z3-solver').Z3_context,
        arg1: import('z3-solver').Z3_ast,
        arg2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_numeral: (
        c: import('z3-solver').Z3_context,
        numeral: string,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_real: (
        c: import('z3-solver').Z3_context,
        num: number,
        den: number
      ) => import('z3-solver').Z3_ast;
      mk_real_int64: (
        c: import('z3-solver').Z3_context,
        num: bigint,
        den: bigint
      ) => import('z3-solver').Z3_ast;
      mk_int: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_unsigned_int: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_int64: (
        c: import('z3-solver').Z3_context,
        v: bigint,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_unsigned_int64: (
        c: import('z3-solver').Z3_context,
        v: bigint,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_bv_numeral: (
        c: import('z3-solver').Z3_context,
        bits: boolean[]
      ) => import('z3-solver').Z3_ast;
      mk_seq_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      is_seq_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      get_seq_sort_basis: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_re_sort: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      is_re_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      get_re_sort_basis: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      mk_string_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_char_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      is_string_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      is_char_sort: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => boolean;
      mk_string: (
        c: import('z3-solver').Z3_context,
        s: string
      ) => import('z3-solver').Z3_ast;
      mk_lstring: (
        c: import('z3-solver').Z3_context,
        len: number,
        s: string
      ) => import('z3-solver').Z3_ast;
      mk_u32string: (
        c: import('z3-solver').Z3_context,
        chars: number[]
      ) => import('z3-solver').Z3_ast;
      is_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => boolean;
      get_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => string;
      get_string_length: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => number;
      get_string_contents: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        length: number
      ) => number[];
      mk_seq_empty: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_seq_unit: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_concat: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_seq_prefix: (
        c: import('z3-solver').Z3_context,
        prefix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_suffix: (
        c: import('z3-solver').Z3_context,
        suffix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_contains: (
        c: import('z3-solver').Z3_context,
        container: import('z3-solver').Z3_ast,
        containee: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_str_lt: (
        c: import('z3-solver').Z3_context,
        prefix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_str_le: (
        c: import('z3-solver').Z3_context,
        prefix: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_extract: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        offset: import('z3-solver').Z3_ast,
        length: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_replace: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        src: import('z3-solver').Z3_ast,
        dst: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_at: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        index: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_nth: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        index: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_length: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_index: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        substr: import('z3-solver').Z3_ast,
        offset: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_last_index: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast,
        substr: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_str_to_int: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_int_to_str: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_string_to_code: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_string_from_code: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_ubv_to_str: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_sbv_to_str: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_to_re: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_seq_in_re: (
        c: import('z3-solver').Z3_context,
        seq: import('z3-solver').Z3_ast,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_plus: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_star: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_option: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_union: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_re_concat: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_re_range: (
        c: import('z3-solver').Z3_context,
        lo: import('z3-solver').Z3_ast,
        hi: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_allchar: (
        c: import('z3-solver').Z3_context,
        regex_sort: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_re_loop: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_ast,
        lo: number,
        hi: number
      ) => import('z3-solver').Z3_ast;
      mk_re_power: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast,
        n: number
      ) => import('z3-solver').Z3_ast;
      mk_re_intersect: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      mk_re_complement: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_diff: (
        c: import('z3-solver').Z3_context,
        re1: import('z3-solver').Z3_ast,
        re2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_re_empty: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_re_full: (
        c: import('z3-solver').Z3_context,
        re: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_char: (
        c: import('z3-solver').Z3_context,
        ch: number
      ) => import('z3-solver').Z3_ast;
      mk_char_le: (
        c: import('z3-solver').Z3_context,
        ch1: import('z3-solver').Z3_ast,
        ch2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_to_int: (
        c: import('z3-solver').Z3_context,
        ch: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_to_bv: (
        c: import('z3-solver').Z3_context,
        ch: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_from_bv: (
        c: import('z3-solver').Z3_context,
        bv: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_char_is_digit: (
        c: import('z3-solver').Z3_context,
        ch: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_linear_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_partial_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_piecewise_linear_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_tree_order: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_sort,
        id: number
      ) => import('z3-solver').Z3_func_decl;
      mk_transitive_closure: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_func_decl;
      mk_pattern: (
        c: import('z3-solver').Z3_context,
        terms: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_pattern;
      mk_bound: (
        c: import('z3-solver').Z3_context,
        index: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_forall: (
        c: import('z3-solver').Z3_context,
        weight: number,
        patterns: import('z3-solver').Z3_pattern[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_exists: (
        c: import('z3-solver').Z3_context,
        weight: number,
        patterns: import('z3-solver').Z3_pattern[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        patterns: import('z3-solver').Z3_pattern[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier_ex: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        quantifier_id: import('z3-solver').Z3_symbol,
        skolem_id: import('z3-solver').Z3_symbol,
        patterns: import('z3-solver').Z3_pattern[],
        no_patterns: import('z3-solver').Z3_ast[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_forall_const: (
        c: import('z3-solver').Z3_context,
        weight: number,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_exists_const: (
        c: import('z3-solver').Z3_context,
        weight: number,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier_const: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_quantifier_const_ex: (
        c: import('z3-solver').Z3_context,
        is_forall: boolean,
        weight: number,
        quantifier_id: import('z3-solver').Z3_symbol,
        skolem_id: import('z3-solver').Z3_symbol,
        bound: import('z3-solver').Z3_app[],
        patterns: import('z3-solver').Z3_pattern[],
        no_patterns: import('z3-solver').Z3_ast[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_lambda: (
        c: import('z3-solver').Z3_context,
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_lambda_const: (
        c: import('z3-solver').Z3_context,
        bound: import('z3-solver').Z3_app[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_symbol_kind: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_symbol_kind;
      get_symbol_int: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => number;
      get_symbol_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_symbol
      ) => string;
      get_sort_name: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_symbol;
      get_sort_id: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      sort_to_ast: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      is_eq_sort: (
        c: import('z3-solver').Z3_context,
        s1: import('z3-solver').Z3_sort,
        s2: import('z3-solver').Z3_sort
      ) => boolean;
      get_sort_kind: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort_kind;
      get_bv_sort_size: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => number;
      get_finite_domain_sort_size: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => bigint | null;
      get_array_sort_domain: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      get_array_sort_domain_n: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx: number
      ) => import('z3-solver').Z3_sort;
      get_array_sort_range: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_sort;
      get_tuple_sort_mk_decl: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      get_tuple_sort_num_fields: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => number;
      get_tuple_sort_field_decl: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        i: number
      ) => import('z3-solver').Z3_func_decl;
      get_datatype_sort_num_constructors: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort
      ) => number;
      get_datatype_sort_constructor: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx: number
      ) => import('z3-solver').Z3_func_decl;
      get_datatype_sort_recognizer: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx: number
      ) => import('z3-solver').Z3_func_decl;
      get_datatype_sort_constructor_accessor: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_sort,
        idx_c: number,
        idx_a: number
      ) => import('z3-solver').Z3_func_decl;
      datatype_update_field: (
        c: import('z3-solver').Z3_context,
        field_access: import('z3-solver').Z3_func_decl,
        t: import('z3-solver').Z3_ast,
        value: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_relation_arity: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      get_relation_column: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort,
        col: number
      ) => import('z3-solver').Z3_sort;
      mk_atmost: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_atleast: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_pble: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        coeffs: number[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_pbge: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        coeffs: number[],
        k: number
      ) => import('z3-solver').Z3_ast;
      mk_pbeq: (
        c: import('z3-solver').Z3_context,
        args: import('z3-solver').Z3_ast[],
        coeffs: number[],
        k: number
      ) => import('z3-solver').Z3_ast;
      func_decl_to_ast: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      is_eq_func_decl: (
        c: import('z3-solver').Z3_context,
        f1: import('z3-solver').Z3_func_decl,
        f2: import('z3-solver').Z3_func_decl
      ) => boolean;
      get_func_decl_id: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_decl
      ) => number;
      get_decl_name: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_symbol;
      get_decl_kind: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_decl_kind;
      get_domain_size: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => number;
      get_arity: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => number;
      get_domain: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        i: number
      ) => import('z3-solver').Z3_sort;
      get_range: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_sort;
      get_decl_num_parameters: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => number;
      get_decl_parameter_kind: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_parameter_kind;
      get_decl_int_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => number;
      get_decl_double_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => number;
      get_decl_symbol_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_symbol;
      get_decl_sort_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_sort;
      get_decl_ast_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_ast;
      get_decl_func_decl_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => import('z3-solver').Z3_func_decl;
      get_decl_rational_parameter: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl,
        idx: number
      ) => string;
      app_to_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app
      ) => import('z3-solver').Z3_ast;
      get_app_decl: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app
      ) => import('z3-solver').Z3_func_decl;
      get_app_num_args: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app
      ) => number;
      get_app_arg: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_app,
        i: number
      ) => import('z3-solver').Z3_ast;
      is_eq_ast: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => boolean;
      get_ast_id: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => number;
      get_ast_hash: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_sort: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_sort;
      is_well_sorted: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      get_bool_value: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_lbool;
      get_ast_kind: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast_kind;
      is_app: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_numeral_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_algebraic_number: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      to_app: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_app;
      to_func_decl: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_func_decl;
      get_numeral_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => string;
      get_numeral_binary_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => string;
      get_numeral_decimal_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        precision: number
      ) => string;
      get_numeral_double: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_numerator: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_denominator: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      get_numeral_small: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => {
        num: bigint;
        den: bigint;
      } | null;
      get_numeral_int: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => number | null;
      get_numeral_uint: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => number | null;
      get_numeral_uint64: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => bigint | null;
      get_numeral_int64: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => bigint | null;
      get_numeral_rational_int64: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast
      ) => {
        num: bigint;
        den: bigint;
      } | null;
      get_algebraic_number_lower: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        precision: number
      ) => import('z3-solver').Z3_ast;
      get_algebraic_number_upper: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        precision: number
      ) => import('z3-solver').Z3_ast;
      pattern_to_ast: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern
      ) => import('z3-solver').Z3_ast;
      get_pattern_num_terms: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern
      ) => number;
      get_pattern: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern,
        idx: number
      ) => import('z3-solver').Z3_ast;
      get_index_value: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      is_quantifier_forall: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_quantifier_exists: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      is_lambda: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      get_quantifier_weight: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_skolem_id: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_symbol;
      get_quantifier_id: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_symbol;
      get_quantifier_num_patterns: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_pattern_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_pattern;
      get_quantifier_num_no_patterns: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_no_pattern_ast: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_ast;
      get_quantifier_num_bound: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      get_quantifier_bound_name: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_symbol;
      get_quantifier_bound_sort: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        i: number
      ) => import('z3-solver').Z3_sort;
      get_quantifier_body: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      simplify: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => Promise<import('z3-solver').Z3_ast>;
      simplify_ex: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        p: import('z3-solver').Z3_params
      ) => Promise<import('z3-solver').Z3_ast>;
      simplify_get_help: (c: import('z3-solver').Z3_context) => string;
      simplify_get_param_descrs: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_param_descrs;
      update_term: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        args: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      substitute: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        from: import('z3-solver').Z3_ast[],
        to: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      substitute_vars: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        to: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      substitute_funs: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        from: import('z3-solver').Z3_func_decl[],
        to: import('z3-solver').Z3_ast[]
      ) => import('z3-solver').Z3_ast;
      translate: (
        source: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        target: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_model: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_model;
      model_inc_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => void;
      model_dec_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => void;
      model_eval: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        t: import('z3-solver').Z3_ast,
        model_completion: boolean
      ) => import('z3-solver').Z3_ast | null;
      model_get_const_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        a: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast | null;
      model_has_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        a: import('z3-solver').Z3_func_decl
      ) => boolean;
      model_get_func_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        f: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_func_interp | null;
      model_get_num_consts: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => number;
      model_get_const_decl: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        i: number
      ) => import('z3-solver').Z3_func_decl;
      model_get_num_funcs: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => number;
      model_get_func_decl: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        i: number
      ) => import('z3-solver').Z3_func_decl;
      model_get_num_sorts: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => number;
      model_get_sort: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        i: number
      ) => import('z3-solver').Z3_sort;
      model_get_sort_universe: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast_vector;
      model_translate: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        dst: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_model;
      is_as_array: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      get_as_array_func_decl: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_func_decl;
      add_func_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        f: import('z3-solver').Z3_func_decl,
        default_value: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_func_interp;
      add_const_interp: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        f: import('z3-solver').Z3_func_decl,
        a: import('z3-solver').Z3_ast
      ) => void;
      func_interp_inc_ref: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => void;
      func_interp_dec_ref: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => void;
      func_interp_get_num_entries: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => number;
      func_interp_get_entry: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp,
        i: number
      ) => import('z3-solver').Z3_func_entry;
      func_interp_get_else: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => import('z3-solver').Z3_ast;
      func_interp_set_else: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp,
        else_value: import('z3-solver').Z3_ast
      ) => void;
      func_interp_get_arity: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_func_interp
      ) => number;
      func_interp_add_entry: (
        c: import('z3-solver').Z3_context,
        fi: import('z3-solver').Z3_func_interp,
        args: import('z3-solver').Z3_ast_vector,
        value: import('z3-solver').Z3_ast
      ) => void;
      func_entry_inc_ref: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => void;
      func_entry_dec_ref: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => void;
      func_entry_get_value: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => import('z3-solver').Z3_ast;
      func_entry_get_num_args: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry
      ) => number;
      func_entry_get_arg: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_func_entry,
        i: number
      ) => import('z3-solver').Z3_ast;
      open_log: (filename: string) => boolean;
      append_log: (string: string) => void;
      close_log: () => void;
      toggle_warning_messages: (enabled: boolean) => void;
      set_ast_print_mode: (
        c: import('z3-solver').Z3_context,
        mode: import('z3-solver').Z3_ast_print_mode
      ) => void;
      ast_to_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => string;
      pattern_to_string: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_pattern
      ) => string;
      sort_to_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => string;
      func_decl_to_string: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_func_decl
      ) => string;
      model_to_string: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model
      ) => string;
      benchmark_to_smtlib_string: (
        c: import('z3-solver').Z3_context,
        name: string,
        logic: string,
        status: string,
        attributes: string,
        assumptions: import('z3-solver').Z3_ast[],
        formula: import('z3-solver').Z3_ast
      ) => string;
      parse_smtlib2_string: (
        c: import('z3-solver').Z3_context,
        str: string,
        sort_names: import('z3-solver').Z3_symbol[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        decls: import('z3-solver').Z3_func_decl[]
      ) => import('z3-solver').Z3_ast_vector;
      parse_smtlib2_file: (
        c: import('z3-solver').Z3_context,
        file_name: string,
        sort_names: import('z3-solver').Z3_symbol[],
        sorts: import('z3-solver').Z3_sort[],
        decl_names: import('z3-solver').Z3_symbol[],
        decls: import('z3-solver').Z3_func_decl[]
      ) => import('z3-solver').Z3_ast_vector;
      eval_smtlib2_string: (
        c: import('z3-solver').Z3_context,
        str: string
      ) => Promise<string>;
      mk_parser_context: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_parser_context;
      parser_context_inc_ref: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context
      ) => void;
      parser_context_dec_ref: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context
      ) => void;
      parser_context_add_sort: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context,
        s: import('z3-solver').Z3_sort
      ) => void;
      parser_context_add_decl: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context,
        f: import('z3-solver').Z3_func_decl
      ) => void;
      parser_context_from_string: (
        c: import('z3-solver').Z3_context,
        pc: import('z3-solver').Z3_parser_context,
        s: string
      ) => import('z3-solver').Z3_ast_vector;
      get_error_code: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_error_code;
      set_error: (
        c: import('z3-solver').Z3_context,
        e: import('z3-solver').Z3_error_code
      ) => void;
      get_error_msg: (
        c: import('z3-solver').Z3_context,
        err: import('z3-solver').Z3_error_code
      ) => string;
      get_version: () => {
        major: number;
        minor: number;
        build_number: number;
        revision_number: number;
      };
      get_full_version: () => string;
      enable_trace: (tag: string) => void;
      disable_trace: (tag: string) => void;
      reset_memory: () => void;
      finalize_memory: () => void;
      mk_goal: (
        c: import('z3-solver').Z3_context,
        models: boolean,
        unsat_cores: boolean,
        proofs: boolean
      ) => import('z3-solver').Z3_goal;
      goal_inc_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => void;
      goal_dec_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => void;
      goal_precision: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => import('z3-solver').Z3_goal_prec;
      goal_assert: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        a: import('z3-solver').Z3_ast
      ) => void;
      goal_inconsistent: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => boolean;
      goal_depth: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => number;
      goal_reset: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => void;
      goal_size: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => number;
      goal_formula: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        idx: number
      ) => import('z3-solver').Z3_ast;
      goal_num_exprs: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => number;
      goal_is_decided_sat: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => boolean;
      goal_is_decided_unsat: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => boolean;
      goal_translate: (
        source: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        target: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_goal;
      goal_convert_model: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        m: import('z3-solver').Z3_model
      ) => import('z3-solver').Z3_model;
      goal_to_string: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal
      ) => string;
      goal_to_dimacs_string: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_goal,
        include_names: boolean
      ) => string;
      mk_tactic: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => import('z3-solver').Z3_tactic;
      tactic_inc_ref: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => void;
      tactic_dec_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_tactic
      ) => void;
      mk_probe: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => import('z3-solver').Z3_probe;
      probe_inc_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => void;
      probe_dec_ref: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => void;
      tactic_and_then: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_or_else: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_par_or: (
        c: import('z3-solver').Z3_context,
        ts: import('z3-solver').Z3_tactic[]
      ) => import('z3-solver').Z3_tactic;
      tactic_par_and_then: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_try_for: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        ms: number
      ) => import('z3-solver').Z3_tactic;
      tactic_when: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe,
        t: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_cond: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe,
        t1: import('z3-solver').Z3_tactic,
        t2: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_tactic;
      tactic_repeat: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        max: number
      ) => import('z3-solver').Z3_tactic;
      tactic_skip: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_tactic;
      tactic_fail: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_tactic;
      tactic_fail_if: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_tactic;
      tactic_fail_if_not_decided: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_tactic;
      tactic_using_params: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        p: import('z3-solver').Z3_params
      ) => import('z3-solver').Z3_tactic;
      mk_simplifier: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => import('z3-solver').Z3_simplifier;
      simplifier_inc_ref: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier
      ) => void;
      simplifier_dec_ref: (
        c: import('z3-solver').Z3_context,
        g: import('z3-solver').Z3_simplifier
      ) => void;
      solver_add_simplifier: (
        c: import('z3-solver').Z3_context,
        solver: import('z3-solver').Z3_solver,
        simplifier: import('z3-solver').Z3_simplifier
      ) => import('z3-solver').Z3_solver;
      simplifier_and_then: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_simplifier,
        t2: import('z3-solver').Z3_simplifier
      ) => import('z3-solver').Z3_simplifier;
      simplifier_using_params: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier,
        p: import('z3-solver').Z3_params
      ) => import('z3-solver').Z3_simplifier;
      get_num_simplifiers: (c: import('z3-solver').Z3_context) => number;
      get_simplifier_name: (
        c: import('z3-solver').Z3_context,
        i: number
      ) => string;
      simplifier_get_help: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier
      ) => string;
      simplifier_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_simplifier
      ) => import('z3-solver').Z3_param_descrs;
      simplifier_get_descr: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => string;
      probe_const: (
        x: import('z3-solver').Z3_context,
        val: number
      ) => import('z3-solver').Z3_probe;
      probe_lt: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_gt: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_le: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_ge: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_eq: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_and: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_or: (
        x: import('z3-solver').Z3_context,
        p1: import('z3-solver').Z3_probe,
        p2: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      probe_not: (
        x: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe
      ) => import('z3-solver').Z3_probe;
      get_num_tactics: (c: import('z3-solver').Z3_context) => number;
      get_tactic_name: (c: import('z3-solver').Z3_context, i: number) => string;
      get_num_probes: (c: import('z3-solver').Z3_context) => number;
      get_probe_name: (c: import('z3-solver').Z3_context, i: number) => string;
      tactic_get_help: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => string;
      tactic_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_param_descrs;
      tactic_get_descr: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => string;
      probe_get_descr: (
        c: import('z3-solver').Z3_context,
        name: string
      ) => string;
      probe_apply: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_probe,
        g: import('z3-solver').Z3_goal
      ) => number;
      tactic_apply: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        g: import('z3-solver').Z3_goal
      ) => Promise<import('z3-solver').Z3_apply_result>;
      tactic_apply_ex: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic,
        g: import('z3-solver').Z3_goal,
        p: import('z3-solver').Z3_params
      ) => Promise<import('z3-solver').Z3_apply_result>;
      apply_result_inc_ref: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => void;
      apply_result_dec_ref: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => void;
      apply_result_to_string: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => string;
      apply_result_get_num_subgoals: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result
      ) => number;
      apply_result_get_subgoal: (
        c: import('z3-solver').Z3_context,
        r: import('z3-solver').Z3_apply_result,
        i: number
      ) => import('z3-solver').Z3_goal;
      mk_solver: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_solver;
      mk_simple_solver: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_solver;
      mk_solver_for_logic: (
        c: import('z3-solver').Z3_context,
        logic: import('z3-solver').Z3_symbol
      ) => import('z3-solver').Z3_solver;
      mk_solver_from_tactic: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_tactic
      ) => import('z3-solver').Z3_solver;
      solver_translate: (
        source: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        target: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_solver;
      solver_import_model_converter: (
        ctx: import('z3-solver').Z3_context,
        src: import('z3-solver').Z3_solver,
        dst: import('z3-solver').Z3_solver
      ) => void;
      solver_get_help: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => string;
      solver_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_param_descrs;
      solver_set_params: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        p: import('z3-solver').Z3_params
      ) => void;
      solver_inc_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_dec_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_interrupt: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_push: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_pop: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        n: number
      ) => void;
      solver_reset: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => void;
      solver_get_num_scopes: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => number;
      solver_assert: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast
      ) => void;
      solver_assert_and_track: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast,
        p: import('z3-solver').Z3_ast
      ) => void;
      solver_from_file: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        file_name: string
      ) => void;
      solver_from_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        file_name: string
      ) => void;
      solver_get_assertions: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_units: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_trail: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_non_units: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_levels: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        literals: import('z3-solver').Z3_ast_vector,
        levels: number[]
      ) => void;
      solver_congruence_root: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      solver_congruence_next: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      solver_next_split: (
        c: import('z3-solver').Z3_context,
        cb: import('z3-solver').Z3_solver_callback,
        t: import('z3-solver').Z3_ast,
        idx: number,
        phase: import('z3-solver').Z3_lbool
      ) => boolean;
      solver_propagate_declare: (
        c: import('z3-solver').Z3_context,
        name: import('z3-solver').Z3_symbol,
        domain: import('z3-solver').Z3_sort[],
        range: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_func_decl;
      solver_propagate_register: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        e: import('z3-solver').Z3_ast
      ) => void;
      solver_propagate_register_cb: (
        c: import('z3-solver').Z3_context,
        cb: import('z3-solver').Z3_solver_callback,
        e: import('z3-solver').Z3_ast
      ) => void;
      solver_propagate_consequence: (
        c: import('z3-solver').Z3_context,
        cb: import('z3-solver').Z3_solver_callback,
        fixed: import('z3-solver').Z3_ast[],
        eq_lhs: import('z3-solver').Z3_ast[],
        eq_rhs: import('z3-solver').Z3_ast[],
        conseq: import('z3-solver').Z3_ast
      ) => boolean;
      solver_check: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => Promise<import('z3-solver').Z3_lbool>;
      solver_check_assumptions: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        assumptions: import('z3-solver').Z3_ast[]
      ) => Promise<import('z3-solver').Z3_lbool>;
      get_implied_equalities: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        terms: import('z3-solver').Z3_ast[]
      ) => {
        rv: import('z3-solver').Z3_lbool;
        class_ids: number[];
      };
      solver_get_consequences: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        assumptions: import('z3-solver').Z3_ast_vector,
        variables: import('z3-solver').Z3_ast_vector,
        consequences: import('z3-solver').Z3_ast_vector
      ) => Promise<import('z3-solver').Z3_lbool>;
      solver_cube: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        vars: import('z3-solver').Z3_ast_vector,
        backtrack_level: number
      ) => Promise<import('z3-solver').Z3_ast_vector>;
      solver_get_model: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_model;
      solver_get_proof: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast;
      solver_get_unsat_core: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_ast_vector;
      solver_get_reason_unknown: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => string;
      solver_get_statistics: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => import('z3-solver').Z3_stats;
      solver_to_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver
      ) => string;
      solver_to_dimacs_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_solver,
        include_names: boolean
      ) => string;
      stats_to_string: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => string;
      stats_inc_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => void;
      stats_dec_ref: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => void;
      stats_size: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats
      ) => number;
      stats_get_key: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => string;
      stats_is_uint: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => boolean;
      stats_is_double: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => boolean;
      stats_get_uint_value: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => number;
      stats_get_double_value: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_stats,
        idx: number
      ) => number;
      get_estimated_alloc_size: () => bigint;
      algebraic_is_value: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_is_pos: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_is_neg: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_is_zero: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_sign: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      algebraic_add: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_sub: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_mul: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_div: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      algebraic_root: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        k: number
      ) => import('z3-solver').Z3_ast;
      algebraic_power: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        k: number
      ) => import('z3-solver').Z3_ast;
      algebraic_lt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_gt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_le: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_ge: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_eq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_neq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast,
        b: import('z3-solver').Z3_ast
      ) => boolean;
      algebraic_roots: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_ast,
        a: import('z3-solver').Z3_ast[]
      ) => Promise<import('z3-solver').Z3_ast_vector>;
      algebraic_eval: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_ast,
        a: import('z3-solver').Z3_ast[]
      ) => Promise<number>;
      algebraic_get_poly: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast_vector;
      algebraic_get_i: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_ast
      ) => number;
      mk_ast_vector: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast_vector;
      ast_vector_inc_ref: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => void;
      ast_vector_dec_ref: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => void;
      ast_vector_size: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => number;
      ast_vector_get: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        i: number
      ) => import('z3-solver').Z3_ast;
      ast_vector_set: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        i: number,
        a: import('z3-solver').Z3_ast
      ) => void;
      ast_vector_resize: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        n: number
      ) => void;
      ast_vector_push: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        a: import('z3-solver').Z3_ast
      ) => void;
      ast_vector_translate: (
        s: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector,
        t: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast_vector;
      ast_vector_to_string: (
        c: import('z3-solver').Z3_context,
        v: import('z3-solver').Z3_ast_vector
      ) => string;
      mk_ast_map: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast_map;
      ast_map_inc_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => void;
      ast_map_dec_ref: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => void;
      ast_map_contains: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast
      ) => boolean;
      ast_map_find: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      ast_map_insert: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast,
        v: import('z3-solver').Z3_ast
      ) => void;
      ast_map_erase: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map,
        k: import('z3-solver').Z3_ast
      ) => void;
      ast_map_reset: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => void;
      ast_map_size: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => number;
      ast_map_keys: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => import('z3-solver').Z3_ast_vector;
      ast_map_to_string: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_ast_map
      ) => string;
      mk_fixedpoint: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_fixedpoint;
      fixedpoint_inc_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => void;
      fixedpoint_dec_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => void;
      fixedpoint_add_rule: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        rule: import('z3-solver').Z3_ast,
        name: import('z3-solver').Z3_symbol
      ) => void;
      fixedpoint_add_fact: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        r: import('z3-solver').Z3_func_decl,
        args: number[]
      ) => void;
      fixedpoint_assert: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        axiom: import('z3-solver').Z3_ast
      ) => void;
      fixedpoint_query: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        query: import('z3-solver').Z3_ast
      ) => Promise<import('z3-solver').Z3_lbool>;
      fixedpoint_query_relations: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        relations: import('z3-solver').Z3_func_decl[]
      ) => Promise<import('z3-solver').Z3_lbool>;
      fixedpoint_get_answer: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast;
      fixedpoint_get_reason_unknown: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => string;
      fixedpoint_update_rule: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        a: import('z3-solver').Z3_ast,
        name: import('z3-solver').Z3_symbol
      ) => void;
      fixedpoint_get_num_levels: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        pred: import('z3-solver').Z3_func_decl
      ) => number;
      fixedpoint_get_cover_delta: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        level: number,
        pred: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      fixedpoint_add_cover: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        level: number,
        pred: import('z3-solver').Z3_func_decl,
        property: import('z3-solver').Z3_ast
      ) => void;
      fixedpoint_get_statistics: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_stats;
      fixedpoint_register_relation: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        f: import('z3-solver').Z3_func_decl
      ) => void;
      fixedpoint_set_predicate_representation: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        f: import('z3-solver').Z3_func_decl,
        relation_kinds: import('z3-solver').Z3_symbol[]
      ) => void;
      fixedpoint_get_rules: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_get_assertions: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_set_params: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        p: import('z3-solver').Z3_params
      ) => void;
      fixedpoint_get_help: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => string;
      fixedpoint_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_param_descrs;
      fixedpoint_to_string: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        queries: import('z3-solver').Z3_ast[]
      ) => string;
      fixedpoint_from_string: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        s: string
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_from_file: (
        c: import('z3-solver').Z3_context,
        f: import('z3-solver').Z3_fixedpoint,
        s: string
      ) => import('z3-solver').Z3_ast_vector;
      mk_fpa_rounding_mode_sort: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_round_nearest_ties_to_even: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rne: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_nearest_ties_to_away: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rna: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_toward_positive: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rtp: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_toward_negative: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rtn: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_toward_zero: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rtz: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_ast;
      mk_fpa_sort: (
        c: import('z3-solver').Z3_context,
        ebits: number,
        sbits: number
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_half: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_16: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_single: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_32: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_double: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_64: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_quadruple: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_sort_128: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_sort;
      mk_fpa_nan: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_inf: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort,
        negative: boolean
      ) => import('z3-solver').Z3_ast;
      mk_fpa_zero: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort,
        negative: boolean
      ) => import('z3-solver').Z3_ast;
      mk_fpa_fp: (
        c: import('z3-solver').Z3_context,
        sgn: import('z3-solver').Z3_ast,
        exp: import('z3-solver').Z3_ast,
        sig: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_float: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_double: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_int: (
        c: import('z3-solver').Z3_context,
        v: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_int_uint: (
        c: import('z3-solver').Z3_context,
        sgn: boolean,
        exp: number,
        sig: number,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_numeral_int64_uint64: (
        c: import('z3-solver').Z3_context,
        sgn: boolean,
        exp: bigint,
        sig: bigint,
        ty: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_abs: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_neg: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_add: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_sub: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_mul: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_div: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_fma: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast,
        t3: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_sqrt: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_rem: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_round_to_integral: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_min: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_max: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_leq: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_lt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_geq: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_gt: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_eq: (
        c: import('z3-solver').Z3_context,
        t1: import('z3-solver').Z3_ast,
        t2: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_normal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_subnormal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_zero: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_infinite: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_nan: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_negative: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_is_positive: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_bv: (
        c: import('z3-solver').Z3_context,
        bv: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_float: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_real: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_signed: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_unsigned: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_ubv: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        sz: number
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_sbv: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast,
        sz: number
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_real: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      fpa_get_ebits: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      fpa_get_sbits: (
        c: import('z3-solver').Z3_context,
        s: import('z3-solver').Z3_sort
      ) => number;
      fpa_is_numeral_nan: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_inf: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_zero: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_normal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_subnormal: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_positive: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_is_numeral_negative: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => boolean;
      fpa_get_numeral_sign_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      fpa_get_numeral_significand_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      fpa_get_numeral_sign: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => number | null;
      fpa_get_numeral_significand_string: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => string;
      fpa_get_numeral_significand_uint64: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => bigint | null;
      fpa_get_numeral_exponent_string: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast,
        biased: boolean
      ) => string;
      fpa_get_numeral_exponent_int64: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast,
        biased: boolean
      ) => bigint | null;
      fpa_get_numeral_exponent_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast,
        biased: boolean
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_ieee_bv: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      mk_fpa_to_fp_int_real: (
        c: import('z3-solver').Z3_context,
        rm: import('z3-solver').Z3_ast,
        exp: import('z3-solver').Z3_ast,
        sig: import('z3-solver').Z3_ast,
        s: import('z3-solver').Z3_sort
      ) => import('z3-solver').Z3_ast;
      mk_optimize: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_optimize;
      optimize_inc_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_dec_ref: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_assert: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        a: import('z3-solver').Z3_ast
      ) => void;
      optimize_assert_and_track: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        a: import('z3-solver').Z3_ast,
        t: import('z3-solver').Z3_ast
      ) => void;
      optimize_assert_soft: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        a: import('z3-solver').Z3_ast,
        weight: string,
        id: import('z3-solver').Z3_symbol
      ) => number;
      optimize_maximize: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        t: import('z3-solver').Z3_ast
      ) => number;
      optimize_minimize: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        t: import('z3-solver').Z3_ast
      ) => number;
      optimize_push: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_pop: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => void;
      optimize_check: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        assumptions: import('z3-solver').Z3_ast[]
      ) => Promise<import('z3-solver').Z3_lbool>;
      optimize_get_reason_unknown: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => string;
      optimize_get_model: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_model;
      optimize_get_unsat_core: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_ast_vector;
      optimize_set_params: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        p: import('z3-solver').Z3_params
      ) => void;
      optimize_get_param_descrs: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_param_descrs;
      optimize_get_lower: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast;
      optimize_get_upper: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast;
      optimize_get_lower_as_vector: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast_vector;
      optimize_get_upper_as_vector: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        idx: number
      ) => import('z3-solver').Z3_ast_vector;
      optimize_to_string: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => string;
      optimize_from_string: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        s: string
      ) => void;
      optimize_from_file: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize,
        s: string
      ) => void;
      optimize_get_help: (
        c: import('z3-solver').Z3_context,
        t: import('z3-solver').Z3_optimize
      ) => string;
      optimize_get_statistics: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_stats;
      optimize_get_assertions: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_ast_vector;
      optimize_get_objectives: (
        c: import('z3-solver').Z3_context,
        o: import('z3-solver').Z3_optimize
      ) => import('z3-solver').Z3_ast_vector;
      polynomial_subresultants: (
        c: import('z3-solver').Z3_context,
        p: import('z3-solver').Z3_ast,
        q: import('z3-solver').Z3_ast,
        x: import('z3-solver').Z3_ast
      ) => Promise<import('z3-solver').Z3_ast_vector>;
      rcf_del: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => void;
      rcf_mk_rational: (
        c: import('z3-solver').Z3_context,
        val: string
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_small_int: (
        c: import('z3-solver').Z3_context,
        val: number
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_pi: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_e: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_infinitesimal: (
        c: import('z3-solver').Z3_context
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mk_roots: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num[]
      ) => {
        rv: number;
        roots: import('z3-solver').Z3_rcf_num[];
      };
      rcf_add: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_sub: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_mul: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_div: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_neg: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_inv: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_rcf_num;
      rcf_power: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        k: number
      ) => import('z3-solver').Z3_rcf_num;
      rcf_lt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_gt: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_le: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_ge: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_eq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_neq: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        b: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_num_to_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        compact: boolean,
        html: boolean
      ) => string;
      rcf_num_to_decimal_string: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        prec: number
      ) => string;
      rcf_get_numerator_denominator: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => {
        n: import('z3-solver').Z3_rcf_num;
        d: import('z3-solver').Z3_rcf_num;
      };
      rcf_is_rational: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_is_algebraic: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_is_infinitesimal: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_is_transcendental: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => boolean;
      rcf_extension_index: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => number;
      rcf_transcendental_name: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_symbol;
      rcf_infinitesimal_name: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => import('z3-solver').Z3_symbol;
      rcf_num_coefficients: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => number;
      rcf_coefficient: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number
      ) => import('z3-solver').Z3_rcf_num;
      rcf_num_sign_conditions: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num
      ) => number;
      rcf_sign_condition_sign: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number
      ) => number;
      rcf_num_sign_condition_coefficients: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number
      ) => number;
      rcf_sign_condition_coefficient: (
        c: import('z3-solver').Z3_context,
        a: import('z3-solver').Z3_rcf_num,
        i: number,
        j: number
      ) => import('z3-solver').Z3_rcf_num;
      fixedpoint_query_from_lvl: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        query: import('z3-solver').Z3_ast,
        lvl: number
      ) => Promise<import('z3-solver').Z3_lbool>;
      fixedpoint_get_ground_sat_answer: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast;
      fixedpoint_get_rules_along_trace: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_ast_vector;
      fixedpoint_get_rule_names_along_trace: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint
      ) => import('z3-solver').Z3_symbol;
      fixedpoint_add_invariant: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        pred: import('z3-solver').Z3_func_decl,
        property: import('z3-solver').Z3_ast
      ) => void;
      fixedpoint_get_reachable: (
        c: import('z3-solver').Z3_context,
        d: import('z3-solver').Z3_fixedpoint,
        pred: import('z3-solver').Z3_func_decl
      ) => import('z3-solver').Z3_ast;
      qe_model_project: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        bound: import('z3-solver').Z3_app[],
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      qe_model_project_skolem: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        bound: import('z3-solver').Z3_app[],
        body: import('z3-solver').Z3_ast,
        map: import('z3-solver').Z3_ast_map
      ) => import('z3-solver').Z3_ast;
      model_extrapolate: (
        c: import('z3-solver').Z3_context,
        m: import('z3-solver').Z3_model,
        fml: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
      qe_lite: (
        c: import('z3-solver').Z3_context,
        vars: import('z3-solver').Z3_ast_vector,
        body: import('z3-solver').Z3_ast
      ) => import('z3-solver').Z3_ast;
    };
    get regionConstrainer(): RegionConstrainer<Name, Core>;
  }
  export declare abstract class Z3Module {
    abstract get id(): string;
    abstract encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name>
    ): void;
  }
  export declare class AreaNumberModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare class CellCountModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare class ConnectAllModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare class DartModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare const allZ3Modules: Map<string, Z3Module>;
  export declare class LetterModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare class MyopiaModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare class RegionAreaModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare class ViewpointModule extends Z3Module {
    readonly id: string;
    encode<Name extends string>(
      grid: GridData,
      ctx: Z3SolverContext<Name, Solver$1<Name> | Optimize<Name>>
    ): void;
  }
  export declare function convertDirection(
    direction: Orientation | Direction
  ): import('grilops').Direction;
  export declare class Z3Solver extends Solver {
    readonly id = 'z3';
    readonly description =
      'Good for confirming that a solution is unique, especially for larger puzzles. It is otherwise slower than most solvers in small to medium-sized puzzles.';
    isEnvironmentSupported(): Promise<boolean>;
    solve(grid: GridData): AsyncGenerator<GridData | null>;
    isInstructionSupported(instructionId: string): boolean;
    isGridSupported(grid: GridData): boolean;
  }
  export declare abstract class CustomSymbol extends MultiEntrySymbol {
    readonly description: string;
    readonly grid: GridData;
    /**
     * **A custom symbol**
     *
     * @param description - The description of the symbol. Leave this empty to hide the description.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     */
    constructor(description: string, grid: GridData, x: number, y: number);
    get explanation(): string;
    createExampleGrid(): GridData;
    validateSymbol(_grid: GridData): State;
    get validateWithSolution(): boolean;
    withDescription(description: string): this;
    withGrid(grid: GridData): this;
  }
  export declare class CustomIconSymbol extends CustomSymbol {
    readonly icon: string;
    readonly rotation: number;
    private static readonly EXAMPLE_GRID;
    private static readonly CONFIGS;
    /**
     * **A custom icon symbol**
     *
     * @param description - The description of the symbol. Leave this empty to hide the description.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param icon - The icon to display. All available icons can be found at https://react-icons.github.io/react-icons/icons/md/
     * @param rotation - The rotation of the icon in degrees.
     */
    constructor(
      description: string,
      grid: GridData,
      x: number,
      y: number,
      icon: string,
      rotation?: number
    );
    get id(): string;
    get configs(): readonly AnyConfig[] | null;
    copyWith({
      description,
      grid,
      x,
      y,
      icon,
      rotation,
    }: {
      description?: string;
      grid?: GridData;
      x?: number;
      y?: number;
      icon?: string;
      rotation?: number;
    }): this;
    withIcon(icon: string): this;
    withRotation(rotation: number): this;
  }
  export declare class CustomTextSymbol extends CustomSymbol {
    readonly text: string;
    readonly rotation: number;
    private static readonly EXAMPLE_GRID;
    private static readonly CONFIGS;
    /**
     * **A custom text symbol**
     *
     * @param description - The description of the symbol. Leave this empty to hide the description.
     * @param grid - The thumbnail grid of the rule, preferably 5x4 in size.
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param text - The text to display.
     * @param rotation - The rotation of the text in degrees.
     */
    constructor(
      description: string,
      grid: GridData,
      x: number,
      y: number,
      text: string,
      rotation?: number
    );
    get id(): string;
    get configs(): readonly AnyConfig[] | null;
    copyWith({
      description,
      grid,
      x,
      y,
      text,
      rotation,
    }: {
      description?: string;
      grid?: GridData;
      x?: number;
      y?: number;
      text?: string;
      rotation?: number;
    }): this;
    withText(text: string): this;
    withRotation(rotation: number): this;
  }
  export declare class HiddenSymbol
    extends Symbol$1
    implements SymbolDisplayHandler
  {
    readonly x: number;
    readonly y: number;
    readonly color: Color;
    readonly revealLocation: boolean;
    private static readonly CONFIGS;
    private static readonly EXAMPLE_GRID;
    /**
     * **Hidden Symbols: color cells correctly to reveal more clues**
     *
     * @param x - The x-coordinate of the symbol.
     * @param y - The y-coordinate of the symbol.
     * @param color - The target color of the cell.
     * @param revealLocation - Whether to reveal the location of the symbol.
     */
    constructor(x: number, y: number, color: Color, revealLocation?: boolean);
    get id(): string;
    get explanation(): string;
    get configs(): readonly AnyConfig[] | null;
    createExampleGrid(): GridData;
    get necessaryForCompletion(): boolean;
    get visibleWhenSolving(): boolean;
    get sortOrder(): number;
    validateSymbol(grid: GridData): State;
    onSymbolDisplay(
      grid: GridData,
      symbol: Symbol$1,
      editing: boolean
    ): boolean;
    copyWith({
      x,
      y,
      color,
      revealLocation,
    }: {
      x?: number;
      y?: number;
      color?: Color;
      revealLocation?: boolean;
    }): this;
    withColor(color: Color): this;
    withRevealLocation(revealLocation: boolean): this;
  }
  export declare const allSymbols: Map<string, Symbol$1>;
  export declare function aggregateState(
    rules: RuleState[],
    grid: GridData,
    symbols: Map<string, State[]>
  ): State;
  export declare function applyFinalOverrides(
    grid: GridData,
    solution: GridData | null,
    state: GridState
  ): GridState;
  export function validateGrid(
    grid: GridData,
    solution: GridData | null
  ): GridState;

  export { Symbol$1 as Symbol, escape$1 as escape, unescape$1 as unescape };

  export {};

  export { Symbol$1 as _Symbol };
}
export {};

/* prettier-ignore-end */
